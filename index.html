<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„Éû„Ç§„ÇØ„É≠„Éê„Éà„É´!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        body {
            font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
            background: #0a0a1a;
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        #game {
            width: 100vw;
            height: 100vh;
            max-width: 500px;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        .screen {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px;
            position: absolute;
            top: 0;
            left: 0;
        }
        .screen.active { display: flex; }

        /* ========== „Çø„Ç§„Éà„É´ÁîªÈù¢ ========== */
        #title {
            background: #000;
            position: relative;
            overflow: hidden;
        }
        .bg-effects {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
        }
        .cyber-grid {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                linear-gradient(90deg, rgba(0,255,255,0.03) 1px, transparent 1px),
                linear-gradient(rgba(0,255,255,0.03) 1px, transparent 1px);
            background-size: 30px 30px;
            animation: gridMove 20s linear infinite;
        }
        @keyframes gridMove {
            0% { background-position: 0 0; }
            100% { background-position: 30px 30px; }
        }
        .aurora {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                radial-gradient(ellipse at 20% 20%, rgba(255,0,128,0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 30%, rgba(0,255,255,0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 80%, rgba(128,0,255,0.3) 0%, transparent 50%);
            animation: auroraShift 8s ease-in-out infinite;
        }
        @keyframes auroraShift { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }
        .particles {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden;
        }
        .particle {
            position: absolute;
            border-radius: 50%;
            animation: floatUp 10s infinite;
            opacity: 0;
        }
        @keyframes floatUp {
            0% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 1; } 90% { opacity: 1; }
            100% { transform: translateY(-100vh) scale(1); opacity: 0; }
        }
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                0deg, transparent 0px, transparent 2px,
                rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 4px
            );
        }
        .title-content {
            position: relative; z-index: 10;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            width: 100%; height: 100%; padding: 20px;
        }
        .title-logo {
            text-align: center;
            margin-bottom: auto;
            padding-top: 12vh;
        }
        .title-icon {
            font-size: 4em; display: block; margin-bottom: 15px;
            animation: iconFloat 3s ease-in-out infinite, iconGlow 2s ease-in-out infinite alternate;
            filter: drop-shadow(0 0 30px rgba(255,255,255,0.8));
        }
        @keyframes iconFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes iconGlow {
            from { filter: drop-shadow(0 0 30px rgba(255,0,255,0.8)); }
            to { filter: drop-shadow(0 0 50px rgba(0,255,255,0.8)); }
        }
        .title-text {
            font-size: 2.2em; font-weight: 900; text-transform: uppercase;
            letter-spacing: 0.1em; color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 40px #ff00ff, 0 0 80px #ff00ff;
            animation: textPulse 2s ease-in-out infinite;
        }
        @keyframes textPulse {
            0%, 100% { text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 40px #ff00ff, 0 0 80px #ff00ff; }
            50% { text-shadow: 0 0 20px #fff, 0 0 40px #fff, 0 0 60px #00ffff, 0 0 100px #00ffff; }
        }
        .title-sub {
            font-size: 0.9em; color: #0ff; letter-spacing: 0.5em;
            margin-top: 10px; text-shadow: 0 0 20px #0ff;
        }
        .start-btn-wrap {
            display: flex; align-items: center; justify-content: center;
        }
        .start-btn {
            position: relative; background: transparent; border: none;
            padding: 22px 70px; font-size: 1.6em; font-weight: bold;
            color: #fff; cursor: pointer; text-transform: uppercase;
            letter-spacing: 0.1em; overflow: hidden; transition: all 0.3s;
        }
        .start-btn::before {
            content: ''; position: absolute; inset: 0;
            background: linear-gradient(45deg, #ff0080, #ff00ff, #8000ff, #0080ff, #00ffff);
            background-size: 400% 400%;
            animation: gradientShift 3s ease infinite;
            border-radius: 50px; z-index: -2;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .start-btn::after {
            content: ''; position: absolute; inset: 3px;
            background: rgba(0,0,0,0.85); border-radius: 47px; z-index: -1;
            transition: background 0.3s;
        }
        .start-btn:hover::after, .start-btn:active::after { background: rgba(0,0,0,0.6); }
        .start-btn span { position: relative; z-index: 1; text-shadow: 0 0 20px #fff; }
        .start-btn:active { transform: scale(0.95); }
        .deco-container {
            display: flex; align-items: center; gap: 20px;
            margin-top: auto; padding-bottom: 10vh;
        }
        .deco-line {
            width: 80px; height: 2px;
            background: linear-gradient(90deg, transparent, #ff00ff, #00ffff, transparent);
            animation: lineGlow 2s infinite;
        }
        @keyframes lineGlow { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        .deco-diamond {
            width: 12px; height: 12px;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            transform: rotate(45deg);
            animation: diamondSpin 4s linear infinite;
            box-shadow: 0 0 15px #ff00ff;
        }
        @keyframes diamondSpin { from { transform: rotate(45deg); } to { transform: rotate(405deg); } }

        /* ========== HUD ========== */
        .hud {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 10px 12px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            z-index: 10;
        }
        .hud-item {
            display: flex; align-items: center; gap: 5px;
            color: #fff; font-weight: bold;
        }
        .lives { font-size: 1.1em; }
        .fever-gauge {
            width: 70px; height: 12px; background: #333;
            border-radius: 6px; overflow: hidden; border: 2px solid #666;
        }
        .fever-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #ffff00, #00ffff);
            background-size: 200% 100%;
            animation: feverGradient 1s linear infinite;
            transition: width 0.3s;
        }
        @keyframes feverGradient {
            0% { background-position: 0% 0%; } 100% { background-position: 200% 0%; }
        }
        .score {
            color: #00ffff; font-size: 1.1em; text-shadow: 0 0 10px #00ffff;
        }
        .combo-display {
            position: absolute; top: 48px; right: 15px;
            color: #ffff00; font-size: 1.1em; font-weight: bold;
            text-shadow: 0 0 15px #ffff00;
        }
        .round-display {
            position: absolute; top: 48px; left: 15px;
            color: #00ff88; font-size: 0.95em; font-weight: bold;
            text-shadow: 0 0 10px #00ff88;
        }
        .speed-display {
            position: absolute; top: 68px; left: 15px;
            color: #ff8800; font-size: 0.8em; font-weight: bold;
            text-shadow: 0 0 10px #ff8800;
        }
        .timer-wrap {
            position: absolute; top: 42px; left: 0; right: 0;
            height: 8px; background: rgba(255,255,255,0.1);
        }
        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ffff);
            transition: width 0.05s linear;
            box-shadow: 0 0 10px currentColor;
        }
        .timer-bar.warn { background: linear-gradient(90deg, #ffcc00, #ff9900); }
        .timer-bar.danger {
            background: linear-gradient(90deg, #ff0044, #ff0088);
            animation: timerPulse 0.2s infinite;
        }
        @keyframes timerPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

        #gameplay {
            background: linear-gradient(180deg, #0a0a2e 0%, #1a0a2e 100%);
        }
        .game-area {
            flex: 1;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            width: 100%; padding-top: 55px;
            position: relative;
        }
        .fever-mode .game-area {
            animation: feverBg 0.3s infinite alternate;
        }
        @keyframes feverBg {
            from { background: rgba(255, 0, 255, 0.15); }
            to { background: rgba(0, 255, 255, 0.15); }
        }

        #mini-canvas {
            border-radius: 12px;
            max-width: 100%;
            touch-action: none;
        }

        .instruction {
            position: absolute;
            top: 58px; left: 0; right: 0;
            text-align: center;
            z-index: 20;
            pointer-events: none;
        }
        .instruction-text {
            display: inline-block;
            font-size: 1.8em; font-weight: 900; color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 30px #ff00ff;
            padding: 8px 25px;
            background: rgba(0,0,0,0.6);
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.3);
            animation: instrPop 0.3s ease-out;
        }
        @keyframes instrPop {
            0% { transform: scale(2); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .round-splash {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.5em; font-weight: 900; color: #fff;
            text-shadow: 0 0 20px #fff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            z-index: 100;
            animation: splashAnim 0.6s forwards;
            pointer-events: none;
        }
        @keyframes splashAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(3) rotate(-10deg); }
            40% { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(0); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        }

        .popup {
            position: fixed;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5em; font-weight: bold;
            pointer-events: none; z-index: 1000;
            animation: popAnim 0.5s forwards;
        }
        @keyframes popAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(1); }
        }
        .popup.nice { color: #00ff88; text-shadow: 0 0 30px #00ff88; }
        .popup.great { color: #00ffff; text-shadow: 0 0 30px #00ffff; }
        .popup.perfect { color: #ff00ff; text-shadow: 0 0 30px #ff00ff; }
        .popup.miss { color: #ff0044; text-shadow: 0 0 30px #ff0044; }
        .popup.fever {
            color: #fff;
            text-shadow: 0 0 30px #ff00ff, 0 0 60px #00ffff;
            font-size: 3em;
        }

        .flash {
            position: fixed; inset: 0;
            pointer-events: none; z-index: 999;
        }
        .flash.hit { animation: flashGreen 0.15s; }
        .flash.miss { animation: flashRed 0.15s; }
        @keyframes flashGreen { from { background: rgba(0, 255, 100, 0.4); } to { background: transparent; } }
        @keyframes flashRed { from { background: rgba(255, 0, 50, 0.4); } to { background: transparent; } }

        .speed-up-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex; align-items: center; justify-content: center;
            z-index: 50; pointer-events: none;
        }
        .speed-up-text {
            font-size: 3em; font-weight: 900; color: #ff4400;
            text-shadow: 0 0 20px #ff4400, 0 0 40px #ff0000;
            animation: speedUpAnim 1s forwards;
        }
        @keyframes speedUpAnim {
            0% { transform: scale(3) rotate(-5deg); opacity: 0; }
            30% { transform: scale(1) rotate(0); opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; transform: scale(0.8); }
        }

        /* ========== ÁµêÊûúÁîªÈù¢ ========== */
        #result {
            position: relative; overflow: hidden;
        }
        #result.lose-bg {
            background: radial-gradient(ellipse at center, #1a1a3a 0%, #0a0a1a 100%);
        }
        #result .result-aurora {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background:
                radial-gradient(ellipse at 30% 30%, rgba(255,0,128,0.2) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 70%, rgba(0,255,255,0.2) 0%, transparent 50%);
            animation: loseAurora 3s ease-in-out infinite alternate;
        }
        @keyframes loseAurora { from { opacity: 0.5; } to { opacity: 1; } }
        .confetti-container {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%; overflow: hidden;
            pointer-events: none; z-index: 1;
        }
        .confetti {
            position: absolute; top: -20px;
            animation: confettiFall linear infinite;
        }
        @keyframes confettiFall {
            0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(1080deg); opacity: 0.8; }
        }
        .result-content {
            position: relative; z-index: 10;
            display: flex; flex-direction: column; align-items: center;
        }
        .result-icon-container { position: relative; margin-bottom: 20px; }
        .result-icon {
            font-size: 5em;
            animation: iconEntry 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            filter: drop-shadow(0 0 30px currentColor);
        }
        @keyframes iconEntry {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        .icon-ring {
            position: absolute; top: 50%; left: 50%;
            width: 150px; height: 150px;
            border: 3px solid rgba(0,255,255,0.3); border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: ringExpand 1.5s ease-out infinite;
        }
        @keyframes ringExpand {
            0% { width: 100px; height: 100px; opacity: 1; }
            100% { width: 250px; height: 250px; opacity: 0; }
        }
        .result-title {
            font-size: 2.2em; font-weight: 900; text-transform: uppercase;
            letter-spacing: 0.1em; margin-bottom: 15px;
            color: #ff6688; text-shadow: 0 0 20px #ff0044;
        }
        .result-score-box {
            background: linear-gradient(135deg, rgba(0,0,0,0.6) 0%, rgba(30,30,60,0.6) 100%);
            border: 2px solid rgba(0,255,255,0.3); border-radius: 20px;
            padding: 20px 50px; margin: 15px 0; text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0,255,255,0.2);
            animation: boxAppear 0.5s ease-out 0.3s both;
        }
        @keyframes boxAppear { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .result-score-label {
            color: #888; font-size: 0.9em; text-transform: uppercase;
            letter-spacing: 0.3em; margin-bottom: 8px;
        }
        .result-score-value {
            font-size: 3em; font-weight: 900; color: #00ffff;
            text-shadow: 0 0 30px #00ffff; font-family: 'Courier New', monospace;
        }
        .result-stats {
            background: rgba(0,0,0,0.4); border-radius: 15px;
            padding: 15px 25px; margin: 10px 0;
            border: 1px solid rgba(255,255,255,0.1);
            animation: boxAppear 0.5s ease-out 0.5s both;
        }
        .stat-row {
            display: flex; justify-content: space-between; align-items: center;
            color: #fff; font-size: 1em; padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1); gap: 30px;
        }
        .stat-row:last-child { border-bottom: none; }
        .stat-value { font-weight: bold; text-shadow: 0 0 10px currentColor; }
        .stat-value.cyan { color: #00ffff; }
        .stat-value.gold { color: #ffd700; }
        .stat-value.pink { color: #ff00ff; }
        .result-buttons {
            display: flex; flex-direction: column; gap: 10px; margin-top: 20px;
            animation: boxAppear 0.5s ease-out 0.7s both;
        }
        .btn {
            background: linear-gradient(145deg, #ff0066, #cc0052);
            color: white; border: none;
            padding: 16px 45px; font-size: 1.2em; font-weight: bold;
            border-radius: 50px; cursor: pointer;
            box-shadow: 0 5px 30px rgba(255, 0, 102, 0.5);
            transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.1em;
            position: relative; overflow: hidden;
        }
        .btn::after {
            content: ''; position: absolute; top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            animation: btnShine 2s infinite;
        }
        @keyframes btnShine { 0% { left: -50%; } 100% { left: 150%; } }
        .btn:active { transform: scale(0.95); }
        .btn-cyan {
            background: linear-gradient(145deg, #00cccc, #009999);
            box-shadow: 0 5px 30px rgba(0, 204, 204, 0.5);
        }
        .btn-small { padding: 12px 30px; font-size: 1em; }
        .highscore-badge {
            background: linear-gradient(145deg, #ffd700, #ff8800);
            color: #000; padding: 8px 20px; border-radius: 30px;
            font-weight: bold; font-size: 1.1em; margin-bottom: 15px;
            animation: badgePop 0.5s ease-out 1s both;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }
        @keyframes badgePop { 0% { transform: scale(0); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    </style>
</head>
<body>
    <div id="game">
        <div class="flash" id="flash"></div>

        <!-- „Çø„Ç§„Éà„É´ÁîªÈù¢ -->
        <div id="title" class="screen active">
            <div class="bg-effects">
                <div class="cyber-grid"></div>
                <div class="aurora"></div>
                <div class="particles" id="particles"></div>
                <div class="scanlines"></div>
            </div>
            <div class="title-content">
                <div class="title-logo">
                    <span class="title-icon">‚ö°</span>
                    <div class="title-text">MICRO<br>BATTLE!</div>
                    <div class="title-sub">ENDLESS MICROGAMES</div>
                </div>
                <div class="start-btn-wrap">
                    <button class="start-btn" onclick="startGame()">
                        <span>‚ñ∂ START</span>
                    </button>
                </div>
                <div style="color:#00ffff; font-size:1.2em; text-shadow:0 0 15px #00ffff; margin-top:10px;">
                    üèÜ BEST: <span id="best-score">0</span>
                </div>
                <div class="deco-container">
                    <div class="deco-line"></div>
                    <div class="deco-diamond"></div>
                    <div class="deco-line"></div>
                </div>
            </div>
        </div>

        <!-- „Ç≤„Éº„É†ÁîªÈù¢ -->
        <div id="gameplay" class="screen">
            <div class="hud">
                <div class="hud-item">
                    <span class="lives" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
                </div>
                <div class="hud-item">
                    <span style="font-size:0.8em;">üî•</span>
                    <div class="fever-gauge">
                        <div class="fever-fill" id="fever-fill" style="width:0%"></div>
                    </div>
                </div>
                <div class="hud-item">
                    <span class="score" id="score">0</span>
                </div>
            </div>
            <div class="round-display" id="round-display">ROUND 1</div>
            <div class="speed-display" id="speed-display">SPEED ‚òÖ‚òÜ‚òÜ‚òÜ‚òÜ</div>
            <div class="combo-display" id="combo"></div>
            <div class="timer-wrap">
                <div class="timer-bar" id="timer"></div>
            </div>
            <div class="instruction" id="instruction"></div>
            <div class="game-area" id="area">
                <canvas id="mini-canvas"></canvas>
            </div>
        </div>

        <!-- ÁµêÊûúÁîªÈù¢ -->
        <div id="result" class="screen">
            <div class="result-aurora"></div>
            <div class="confetti-container" id="confetti"></div>
            <div class="result-content" id="result-content"></div>
        </div>
    </div>

<script>
// ======================================================
// „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„ÉªÂÆöÊï∞
// ======================================================
let highScore = parseInt(localStorage.getItem('microBattleHigh')) || 0;
document.getElementById('best-score').textContent = highScore.toLocaleString();

const canvas = document.getElementById('mini-canvas');
const ctx = canvas.getContext('2d');
let CW, CH;

function resizeCanvas() {
    const w = Math.min(window.innerWidth, 500);
    const h = window.innerHeight;
    CW = w - 20;
    CH = Math.min(h - 140, CW * 1.2);
    canvas.width = CW;
    canvas.height = CH;
    canvas.style.width = CW + 'px';
    canvas.style.height = CH + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// „Çø„Ç§„Éà„É´„Éë„Éº„ÉÜ„Ç£„ÇØ„É´
(function createParticles() {
    const container = document.getElementById('particles');
    for (let i = 0; i < 25; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        p.style.left = Math.random() * 100 + '%';
        p.style.animationDelay = Math.random() * 10 + 's';
        p.style.animationDuration = (8 + Math.random() * 8) + 's';
        const size = 2 + Math.random() * 5;
        p.style.width = size + 'px'; p.style.height = size + 'px';
        const colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0088', '#00ff88'];
        const color = colors[Math.floor(Math.random() * colors.length)];
        p.style.background = color;
        p.style.boxShadow = `0 0 ${size * 3}px ${color}`;
        container.appendChild(p);
    }
})();

// ======================================================
// „Ç≤„Éº„É†Áä∂ÊÖã
// ======================================================
let G = {};
let miniGame = null;
let animId = null;

function resetG() {
    G = {
        round: 0,
        lives: 4,
        score: 0,
        combo: 0,
        maxCombo: 0,
        fever: 0,
        isFever: false,
        timerInterval: null,
        timeLeft: 0,
        baseTime: 5500,
        speedLevel: 1,
        wins: 0,
        losses: 0,
        totalGames: 0,
    };
}

// ======================================================
// ÁîªÈù¢Âàá„ÇäÊõø„Åà
// ======================================================
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    document.getElementById('gameplay').classList.remove('fever-mode');
}

// ======================================================
// HUDÊõ¥Êñ∞
// ======================================================
function updateHUD() {
    const maxLives = 4;
    document.getElementById('lives').textContent =
        '‚ù§Ô∏è'.repeat(G.lives) + 'üñ§'.repeat(maxLives - G.lives);
    document.getElementById('score').textContent = G.score.toLocaleString();
    document.getElementById('combo').textContent =
        G.combo > 1 ? `${G.combo} COMBO!` : '';
    document.getElementById('fever-fill').style.width =
        `${Math.min(G.fever, 100)}%`;
    document.getElementById('round-display').textContent = `ROUND ${G.round}`;
    const stars = '‚òÖ'.repeat(G.speedLevel) + '‚òÜ'.repeat(5 - G.speedLevel);
    document.getElementById('speed-display').textContent = `SPEED ${stars}`;
}

// ======================================================
// „Çø„Ç§„Éû„Éº
// ======================================================
function getTimeForRound() {
    const base = G.baseTime;
    const speedMult = 1 - (G.speedLevel - 1) * 0.13;
    return Math.max(1800, base * speedMult);
}

function startTimer(time, onTimeout) {
    clearInterval(G.timerInterval);
    G.timeLeft = time;
    const bar = document.getElementById('timer');
    bar.style.width = '100%';
    bar.className = 'timer-bar';
    G.timerInterval = setInterval(() => {
        G.timeLeft -= 30;
        const pct = G.timeLeft / time * 100;
        bar.style.width = pct + '%';
        if (pct < 25) bar.className = 'timer-bar danger';
        else if (pct < 50) bar.className = 'timer-bar warn';
        if (G.timeLeft <= 0) {
            clearInterval(G.timerInterval);
            if (onTimeout) onTimeout();
        }
    }, 30);
}

function stopTimer() { clearInterval(G.timerInterval); }

// ======================================================
// ÊåáÁ§∫„ÉªÊºîÂá∫
// ======================================================
function showInstruction(text) {
    document.getElementById('instruction').innerHTML =
        `<div class="instruction-text">${text}</div>`;
}
function hideInstruction() {
    document.getElementById('instruction').innerHTML = '';
}

function popup(text, type) {
    const p = document.createElement('div');
    p.className = `popup ${type}`;
    p.textContent = text;
    document.body.appendChild(p);
    setTimeout(() => p.remove(), 600);
}

function flash(type) {
    const f = document.getElementById('flash');
    f.className = 'flash ' + type;
    setTimeout(() => f.className = 'flash', 200);
}

function showSplash(text, callback, delay = 500) {
    const area = document.getElementById('area');
    const splash = document.createElement('div');
    splash.className = 'round-splash';
    splash.textContent = text;
    area.appendChild(splash);
    setTimeout(() => {
        if (splash.parentNode) splash.remove();
        if (callback) callback();
    }, delay);
}

function showSpeedUp() {
    const el = document.createElement('div');
    el.className = 'speed-up-overlay';
    el.innerHTML = '<div class="speed-up-text">‚ö° SPEED UP! ‚ö°</div>';
    document.getElementById('gameplay').appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

// ======================================================
// „Ç≤„Éº„É†ÈñãÂßã„ÉªÈÄ≤Ë°å
// ======================================================
function startGame() {
    resetG();
    showScreen('gameplay');
    hideInstruction();
    updateHUD();
    showSplash('READY', () => showSplash('GO!', nextRound, 300), 500);
}

function nextRound() {
    if (G.lives <= 0) return endGame();
    G.round++;
    G.totalGames++;

    // 5„É©„Ç¶„É≥„Éâ„Åî„Å®„Å´„Çπ„Éî„Éº„Éâ„Ç¢„ÉÉ„Éó
    const newSpeed = Math.min(5, Math.floor((G.round - 1) / 5) + 1);
    if (newSpeed > G.speedLevel) {
        G.speedLevel = newSpeed;
        showSpeedUp();
        updateHUD();
        setTimeout(() => playMiniGame(), 900);
        return;
    }

    // „Éï„Ç£„Éº„Éê„ÉºÂà§ÂÆö
    if (G.fever >= 100 && !G.isFever) {
        G.isFever = true;
        document.getElementById('gameplay').classList.add('fever-mode');
        popup('üî• FEVER! üî•', 'fever');
    }

    updateHUD();
    playMiniGame();
}

// ======================================================
// „Éü„Éã„Ç≤„Éº„É†ÈÅ∏Êäû„ÉªÂÆüË°å„É´„Éº„Éó
// ======================================================
function playMiniGame() {
    if (animId) { cancelAnimationFrame(animId); animId = null; }

    const idx = Math.floor(Math.random() * MINIGAMES.length);
    miniGame = MINIGAMES[idx]();
    miniGame.finished = false;

    showInstruction(miniGame.instruction);
    const time = getTimeForRound();
    miniGame.timeLimit = time;

    // ÊåáÁ§∫„ÇíË™≠„ÇÄÁå∂‰∫à
    setTimeout(() => {
        if (miniGame.finished) return;
        startTimer(time, () => {
            if (!miniGame.finished) {
                if (miniGame.onTimeout) miniGame.onTimeout();
                else miniGameFail();
            }
        });
        miniGame.start();
        runMiniGame();
    }, 550);
}

function runMiniGame() {
    if (!miniGame || miniGame.finished) return;
    ctx.clearRect(0, 0, CW, CH);
    miniGame.update();
    miniGame.draw();
    animId = requestAnimationFrame(runMiniGame);
}

// ======================================================
// „Éü„Éã„Ç≤„Éº„É†ÂãùÊïóÂá¶ÁêÜ
// ======================================================
function miniGameWin() {
    if (miniGame.finished) return;
    miniGame.finished = true;
    stopTimer();
    hideInstruction();
    if (animId) { cancelAnimationFrame(animId); animId = null; }

    G.combo++;
    G.wins++;
    if (G.combo > G.maxCombo) G.maxCombo = G.combo;
    const mult = G.isFever ? 2 : 1;
    const pts = (100 + G.combo * 25) * mult;
    G.score += pts;
    G.fever = Math.min(G.fever + 15, 100);

    flash('hit');
    if (G.combo >= 10) popup('üåü AMAZING!', 'perfect');
    else if (G.combo >= 5) popup('üî• PERFECT!', 'perfect');
    else if (G.combo >= 3) popup('GREAT!', 'great');
    else popup(`+${pts}`, 'nice');

    updateHUD();
    ctx.fillStyle = 'rgba(0,255,100,0.3)';
    ctx.fillRect(0, 0, CW, CH);
    setTimeout(nextRound, 500);
}

function miniGameFail() {
    if (miniGame.finished) return;
    miniGame.finished = true;
    stopTimer();
    hideInstruction();
    if (animId) { cancelAnimationFrame(animId); animId = null; }

    G.lives--;
    G.losses++;
    G.combo = 0;
    G.fever = Math.max(G.fever - 30, 0);
    G.isFever = false;
    document.getElementById('gameplay').classList.remove('fever-mode');

    flash('miss');
    popup('MISS...', 'miss');
    ctx.fillStyle = 'rgba(255,0,50,0.3)';
    ctx.fillRect(0, 0, CW, CH);
    updateHUD();

    setTimeout(() => {
        if (G.lives <= 0) endGame();
        else nextRound();
    }, 600);
}

// ======================================================
// „Çø„ÉÉ„ÉÅ/„Éû„Ç¶„ÇπÂÖ•Âäõ
// ======================================================
let touchState = {
    down: false, x: 0, y: 0, sx: 0, sy: 0, moved: false
};

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.touches[0];
    const r = canvas.getBoundingClientRect();
    touchState.down = true;
    touchState.x = (t.clientX - r.left) * (CW / r.width);
    touchState.y = (t.clientY - r.top) * (CH / r.height);
    touchState.sx = touchState.x;
    touchState.sy = touchState.y;
    touchState.moved = false;
    if (miniGame && !miniGame.finished && miniGame.onDown)
        miniGame.onDown(touchState.x, touchState.y);
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const t = e.touches[0];
    const r = canvas.getBoundingClientRect();
    touchState.x = (t.clientX - r.left) * (CW / r.width);
    touchState.y = (t.clientY - r.top) * (CH / r.height);
    touchState.moved = true;
    if (miniGame && !miniGame.finished && miniGame.onMove)
        miniGame.onMove(touchState.x, touchState.y);
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    touchState.down = false;
    if (miniGame && !miniGame.finished && miniGame.onUp)
        miniGame.onUp(touchState.x, touchState.y, touchState.sx, touchState.sy);
}, { passive: false });

canvas.addEventListener('mousedown', e => {
    const r = canvas.getBoundingClientRect();
    touchState.down = true;
    touchState.x = (e.clientX - r.left) * (CW / r.width);
    touchState.y = (e.clientY - r.top) * (CH / r.height);
    touchState.sx = touchState.x;
    touchState.sy = touchState.y;
    touchState.moved = false;
    if (miniGame && !miniGame.finished && miniGame.onDown)
        miniGame.onDown(touchState.x, touchState.y);
});
canvas.addEventListener('mousemove', e => {
    const r = canvas.getBoundingClientRect();
    touchState.x = (e.clientX - r.left) * (CW / r.width);
    touchState.y = (e.clientY - r.top) * (CH / r.height);
    touchState.moved = true;
    if (touchState.down && miniGame && !miniGame.finished && miniGame.onMove)
        miniGame.onMove(touchState.x, touchState.y);
});
canvas.addEventListener('mouseup', e => {
    touchState.down = false;
    if (miniGame && !miniGame.finished && miniGame.onUp)
        miniGame.onUp(touchState.x, touchState.y, touchState.sx, touchState.sy);
});

// ======================================================
// „Éò„É´„Éë„ÉºÊèèÁîªÈñ¢Êï∞ÔºàÂÖÉ„ÅÆ„É≠„ÉÉ„ÇØ„Éû„É≥È¢®„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØÂÆåÂÖ®ÁßªÊ§çÔºâ
// ======================================================
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

function roundRect(x, y, w, h, r) {
    if (w < 0 || h < 0) return;
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

// ---------- „Éó„É¨„Ç§„É§„ÉºÔºà„É≠„ÉÉ„ÇØ„Éû„É≥ÔºâÊèèÁîª ----------
function drawPlayer(x, y, facing, walkPhase, grounded, shootTimer, invincible, armAngle, landSquash, jumpStretch, eyeBlink) {
    const f = facing || 1;
    const walk = walkPhase || 0;
    const sTimer = shootTimer || 0;
    const aAngle = armAngle || 0;
    const lSquash = landSquash || 0;
    const jStretch = jumpStretch || 0;
    const eBlink = eyeBlink || 999;
    const w = 22, h = 30;
    const cx = x + w / 2, cy = y + h;

    ctx.save();
    if (invincible > 0 && Math.sin(invincible * 0.5) < 0) {
        ctx.restore(); return;
    }

    const squash = 1 + lSquash * 0.15;
    const stretch = 1 + jStretch * 0.1;
    ctx.translate(cx, cy);
    ctx.scale(1 / stretch * squash, stretch / squash);
    ctx.translate(-cx, -cy);

    // ÂΩ±
    ctx.fillStyle = '#0004';
    ctx.beginPath(); ctx.ellipse(cx, cy + 2, 12, 3, 0, 0, Math.PI * 2); ctx.fill();

    // ËÑö
    const legSwing = grounded ? Math.sin(walk * 4) * 0.4 : 0.2;
    drawLimb(cx - 4, cy - 10, 8, 12, -legSwing, '#1a5fc9', '#1650b0');
    drawLimb(cx + 4, cy - 10, 8, 12, legSwing, '#1a5fc9', '#1650b0');

    // „Éñ„Éº„ÉÑ
    const bootOff1 = Math.sin(walk * 4) * 3;
    const bootOff2 = Math.sin(walk * 4 + Math.PI) * 3;
    drawBoot(cx - 6, cy - 3 + bootOff1 * 0.3, '#2a70dd', '#1a5fc9');
    drawBoot(cx + 2, cy - 3 + bootOff2 * 0.3, '#2a70dd', '#1a5fc9');

    // „Éú„Éá„Ç£
    const bodyGrad = ctx.createLinearGradient(cx - 9, y + 8, cx + 9, y + 8);
    bodyGrad.addColorStop(0, '#1e6ae0');
    bodyGrad.addColorStop(0.5, '#3a8aff');
    bodyGrad.addColorStop(1, '#1e6ae0');
    ctx.fillStyle = bodyGrad;
    roundRect(cx - 9, y + 8, 18, 14, 3); ctx.fill();

    // ËÉ∏„ÅÆ„É©„Ç§„Éà
    const gt = (typeof gameTime !== 'undefined') ? gameTime : 0;
    ctx.fillStyle = `rgba(100,255,200,${0.5 + 0.3 * Math.sin(gt * 3)})`;
    ctx.beginPath(); ctx.arc(cx, y + 14, 2.5, 0, Math.PI * 2); ctx.fill();

    // ËÖï / „Éê„Çπ„Çø„Éº
    const armY = y + 10;
    const busterX = f > 0 ? cx + 8 : cx - 18;
    ctx.fillStyle = '#2a70dd';
    roundRect(f > 0 ? cx + 6 : cx - 16, armY + aAngle * 5, 10, 7, 3); ctx.fill();
    const bg = ctx.createLinearGradient(busterX, armY - 1, busterX + 12, armY + 9);
    bg.addColorStop(0, '#4a9aff'); bg.addColorStop(1, '#2a70dd');
    ctx.fillStyle = bg;
    roundRect(busterX, armY - 1 + aAngle * 5, 12, 9, 4); ctx.fill();
    ctx.fillStyle = '#1a50a0';
    ctx.beginPath();
    ctx.arc(f > 0 ? busterX + 11 : busterX + 1, armY + 3.5 + aAngle * 5, 3, 0, Math.PI * 2);
    ctx.fill();
    if (sTimer > 5) {
        ctx.fillStyle = `rgba(100,200,255,${(sTimer - 5) / 5})`;
        ctx.beginPath();
        ctx.arc(f > 0 ? busterX + 12 : busterX, armY + 3.5, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    // È†≠Ôºà„Éò„É´„É°„ÉÉ„ÉàÔºâ
    const headGrad = ctx.createRadialGradient(cx, y + 4, 2, cx, y + 6, 14);
    headGrad.addColorStop(0, '#5aadff');
    headGrad.addColorStop(0.6, '#2a7aee');
    headGrad.addColorStop(1, '#1a5ac8');
    ctx.fillStyle = headGrad;
    ctx.beginPath(); ctx.arc(cx, y + 7, 11, 0, Math.PI * 2); ctx.fill();

    // „Éò„É´„É°„ÉÉ„Éà‰∏äÈÉ®
    ctx.fillStyle = '#4a9aff';
    ctx.beginPath();
    ctx.ellipse(cx, y + 1, 8, 3, 0, Math.PI, 0); ctx.fill();

    // ËÄ≥„Ç∏„Çß„É†
    ctx.fillStyle = '#4af8';
    ctx.beginPath(); ctx.arc(f > 0 ? cx - 9 : cx + 9, y + 7, 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#8df';
    ctx.beginPath(); ctx.arc(f > 0 ? cx - 9 : cx + 9, y + 6, 2, 0, Math.PI * 2); ctx.fill();

    // È°î
    const faceX = f > 0 ? cx - 1 : cx - 9;
    ctx.fillStyle = '#fdd8b8';
    roundRect(faceX, y + 3, 10, 9, 3); ctx.fill();

    // ÁõÆ
    const eyeX = f > 0 ? cx + 3 : cx - 5;
    const blinking = eBlink < 4;
    if (blinking) {
        ctx.strokeStyle = '#222'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(eyeX - 2, y + 7); ctx.lineTo(eyeX + 3, y + 7); ctx.stroke();
    } else {
        ctx.fillStyle = '#fff';
        roundRect(eyeX - 2, y + 4, 5, 5, 2); ctx.fill();
        ctx.fillStyle = '#1a3a5a';
        ctx.beginPath(); ctx.arc(eyeX + 1, y + 7, 1.8, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(eyeX + 2, y + 5.5, 0.8, 0, Math.PI * 2); ctx.fill();
    }

    // Âè£
    ctx.fillStyle = '#c88';
    ctx.beginPath(); ctx.arc(f > 0 ? cx + 2 : cx - 4, y + 10, 1.2, 0, Math.PI); ctx.fill();

    ctx.restore();
}

function drawLimb(x, y, w, h, angle, c1, c2) {
    ctx.save();
    ctx.translate(x + w / 2, y);
    ctx.rotate(angle);
    const g = ctx.createLinearGradient(-w / 2, 0, w / 2, 0);
    g.addColorStop(0, c2); g.addColorStop(0.5, c1); g.addColorStop(1, c2);
    ctx.fillStyle = g;
    roundRect(-w / 2, 0, w, h, 3); ctx.fill();
    ctx.restore();
}

function drawBoot(x, y, c1, c2) {
    ctx.fillStyle = c1;
    roundRect(x, y, 10, 5, 2); ctx.fill();
    ctx.fillStyle = c2;
    ctx.fillRect(x + 1, y + 3, 8, 2);
}

// ---------- „É°„ÉÉ„ÉàÊèèÁîª ----------
function drawMet(x, y, hiding, scale) {
    const s = scale || 1;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    const cx = 0, cy = 0;

    ctx.fillStyle = '#0003';
    ctx.beginPath(); ctx.ellipse(cx, cy + 12, 10, 3, 0, 0, Math.PI * 2); ctx.fill();

    if (hiding) {
        ctx.fillStyle = '#555';
        roundRect(cx - 8, cy, 16, 10, 3); ctx.fill();
        const hatGrad = ctx.createRadialGradient(cx, cy - 4, 2, cx, cy, 16);
        hatGrad.addColorStop(0, '#ffe040'); hatGrad.addColorStop(1, '#cc9900');
        ctx.fillStyle = hatGrad;
        ctx.beginPath(); ctx.arc(cx, cy, 14, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#eec820';
        ctx.beginPath(); ctx.ellipse(cx, cy, 15, 4, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.arc(cx - 4, cy, 1.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 4, cy, 1.5, 0, Math.PI * 2); ctx.fill();
    } else {
        ctx.fillStyle = '#444';
        roundRect(cx - 8, cy - 4, 16, 14, 4); ctx.fill();
        ctx.fillStyle = '#ff3030';
        ctx.beginPath(); ctx.arc(cx - 4, cy + 1, 3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 4, cy + 1, 3, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(cx - 3.5, cy, 1, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 4.5, cy, 1, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ffe040';
        ctx.save();
        ctx.translate(cx, cy - 4);
        ctx.rotate(-0.5);
        ctx.beginPath(); ctx.arc(0, 0, 13, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#eec820';
        ctx.beginPath(); ctx.ellipse(0, 0, 14, 3, 0, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }
    ctx.restore();
}

// ---------- „Çπ„Éä„Ç§„Éë„ÉºÊèèÁîª ----------
function drawSniper(x, y, dir, scale) {
    const s = scale || 1;
    const d = dir || -1;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    const cx = 0, cy = 0;

    ctx.fillStyle = '#0003';
    ctx.beginPath(); ctx.ellipse(cx, cy + 15, 10, 3, 0, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = '#a02020';
    roundRect(cx - 7, cy + 5, 5, 10, 2); ctx.fill();
    roundRect(cx + 2, cy + 5, 5, 10, 2); ctx.fill();

    const bg = ctx.createLinearGradient(cx - 9, cy - 9, cx + 9, cy - 9);
    bg.addColorStop(0, '#cc2020'); bg.addColorStop(0.5, '#ee3333'); bg.addColorStop(1, '#cc2020');
    ctx.fillStyle = bg;
    roundRect(cx - 9, cy - 9, 18, 16, 4); ctx.fill();

    const hg = ctx.createRadialGradient(cx, cy - 11, 2, cx, cy - 9, 10);
    hg.addColorStop(0, '#ee4444'); hg.addColorStop(1, '#aa2020');
    ctx.fillStyle = hg;
    ctx.beginPath(); ctx.arc(cx, cy - 9, 9, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = '#220';
    roundRect(cx - 7, cy - 12, 14, 6, 3); ctx.fill();

    ctx.fillStyle = '#ff0';
    const eyeX = d > 0 ? cx + 2 : cx - 4;
    ctx.beginPath(); ctx.arc(eyeX, cy - 9, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fa0';
    ctx.beginPath(); ctx.arc(eyeX, cy - 9, 1.2, 0, Math.PI * 2); ctx.fill();

    const gunX = d > 0 ? cx + 8 : cx - 18;
    ctx.fillStyle = '#888';
    roundRect(gunX, cy - 5, 12, 5, 2); ctx.fill();
    ctx.fillStyle = '#aaa';
    roundRect(d > 0 ? gunX + 8 : gunX, cy - 6, 4, 7, 1); ctx.fill();

    ctx.restore();
}

// ---------- „Éï„É©„Ç§ÊïµÊèèÁîª ----------
function drawFlyEnemy(x, y, frame, scale) {
    const s = scale || 1;
    const fr = frame || 0;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    const cx = 0, cy = 0;
    const wingPhase = fr * 0.3;

    ctx.fillStyle = `rgba(180,100,255,0.15)`;
    ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = '#c8f4';
    const wAng1 = Math.sin(wingPhase) * 0.5;
    const wAng2 = Math.sin(wingPhase + Math.PI) * 0.5;
    ctx.save(); ctx.translate(cx - 8, cy - 2); ctx.rotate(wAng1);
    ctx.beginPath(); ctx.ellipse(0, 0, 12, 4, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
    ctx.save(); ctx.translate(cx + 8, cy - 2); ctx.rotate(wAng2);
    ctx.beginPath(); ctx.ellipse(0, 0, 12, 4, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();

    const bg = ctx.createRadialGradient(cx, cy, 2, cx, cy, 13);
    bg.addColorStop(0, '#cc66ff'); bg.addColorStop(0.7, '#9933cc'); bg.addColorStop(1, '#6622aa');
    ctx.fillStyle = bg;
    ctx.beginPath(); ctx.arc(cx, cy, 12, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(cx, cy - 2, 6, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#f22';
    ctx.beginPath(); ctx.arc(cx + 1, cy - 2, 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(cx + 2.5, cy - 3.5, 1.2, 0, Math.PI * 2); ctx.fill();

    ctx.restore();
}

// ---------- „Éú„ÇπÊèèÁîª ----------
function drawBoss(x, y, hp, maxHp, dir, frame, scale) {
    const s = scale || 1;
    const d = dir || -1;
    const fr = frame || 0;
    const gt = fr / 60;
    const phase2 = hp < maxHp / 2;
    const pulse = Math.sin(gt * 6) * 0.5 + 0.5;
    const breathe = Math.sin(gt * 2) * 2;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    const cx = 0, cy = 0;
    const bw = 52, bh = 58;

    // ÂΩ±
    ctx.fillStyle = '#0005';
    ctx.beginPath(); ctx.ellipse(cx, cy + bh / 2 + 2, 24, 5, 0, 0, Math.PI * 2); ctx.fill();

    // „Ç™„Éº„É©Ôºà„Éï„Çß„Éº„Ç∫2Ôºâ
    if (phase2) {
        ctx.fillStyle = `rgba(255,60,30,${0.1 + pulse * 0.1})`;
        ctx.beginPath(); ctx.arc(cx, cy, 40 + pulse * 5, 0, Math.PI * 2); ctx.fill();
    }

    const topY = -bh / 2;

    // Ë∂≥
    ctx.fillStyle = '#8b1a1a';
    roundRect(cx - 22, cy + bh / 2 - 8, 16, 8, 3); ctx.fill();
    roundRect(cx + 6, cy + bh / 2 - 8, 16, 8, 3); ctx.fill();

    // ËÑö
    ctx.fillStyle = '#a52020';
    roundRect(cx - 18, cy + bh / 2 - 22, 10, 16, 3); ctx.fill();
    roundRect(cx + 8, cy + bh / 2 - 22, 10, 16, 3); ctx.fill();

    // „Éú„Éá„Ç£
    const bodyG = ctx.createLinearGradient(cx - 20, topY + 14, cx + 20, topY + 14);
    bodyG.addColorStop(0, '#cc2200'); bodyG.addColorStop(0.3, '#ee4400');
    bodyG.addColorStop(0.7, '#ee4400'); bodyG.addColorStop(1, '#cc2200');
    ctx.fillStyle = bodyG;
    roundRect(cx - 20, topY + 14 + breathe * 0.5, 40, 30, 6); ctx.fill();

    // ËÉ∏„Ç®„É≥„Éñ„É¨„É†
    ctx.fillStyle = phase2 ? `rgba(255,${100 + pulse * 155},0,0.9)` : '#ff880088';
    ctx.beginPath(); ctx.arc(cx, topY + 28 + breathe * 0.5, 5, 0, Math.PI * 2); ctx.fill();
    if (phase2) {
        ctx.strokeStyle = `rgba(255,200,0,${pulse * 0.5})`; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, topY + 28 + breathe * 0.5, 8 + pulse * 3, 0, Math.PI * 2); ctx.stroke();
    }

    // ËÇ©
    const sg = ctx.createRadialGradient(cx - 22, topY + 18, 2, cx - 22, topY + 18, 12);
    sg.addColorStop(0, '#ee5500'); sg.addColorStop(1, '#aa2200');
    ctx.fillStyle = sg;
    ctx.beginPath(); ctx.arc(cx - 22, topY + 20, 11, 0, Math.PI * 2); ctx.fill();
    const sg2 = ctx.createRadialGradient(cx + 22, topY + 18, 2, cx + 22, topY + 18, 12);
    sg2.addColorStop(0, '#ee5500'); sg2.addColorStop(1, '#aa2200');
    ctx.fillStyle = sg2;
    ctx.beginPath(); ctx.arc(cx + 22, topY + 20, 11, 0, Math.PI * 2); ctx.fill();

    // ËÇ©„Çπ„Éë„Ç§„ÇØ
    ctx.fillStyle = '#ffcc00';
    drawSpike(cx - 28, topY + 14, 5, 8);
    drawSpike(cx + 28, topY + 14, 5, 8);

    // È†≠
    const headG = ctx.createRadialGradient(cx, topY + 6, 3, cx, topY + 8, 14);
    headG.addColorStop(0, '#ee4400'); headG.addColorStop(1, '#aa1100');
    ctx.fillStyle = headG;
    ctx.beginPath(); ctx.arc(cx, topY + 10, 14, 0, Math.PI * 2); ctx.fill();

    // „Éò„É´„É°„ÉÉ„Éà‰∏ä
    ctx.fillStyle = '#cc2200';
    ctx.beginPath();
    ctx.moveTo(cx - 10, topY + 2); ctx.lineTo(cx, topY - 8); ctx.lineTo(cx + 10, topY + 2);
    ctx.closePath(); ctx.fill();

    // „Éê„Ç§„Ç∂„Éº
    ctx.fillStyle = '#220800';
    roundRect(cx - 11, topY + 4, 22, 8, 4); ctx.fill();

    // ÁõÆ
    const eyeColor = phase2 ? `rgb(255,${150 + pulse * 105},0)` : '#ff4';
    ctx.fillStyle = eyeColor;
    ctx.beginPath(); ctx.arc(cx - 5, topY + 8, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 5, topY + 8, 3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = phase2 ? '#f00' : '#a00';
    ctx.beginPath(); ctx.arc(cx - 5 + (d > 0 ? 1 : -1), topY + 8, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 5 + (d > 0 ? 1 : -1), topY + 8, 1.5, 0, Math.PI * 2); ctx.fill();

    // Âè£
    ctx.fillStyle = '#400';
    roundRect(cx - 7, topY + 14, 14, 5, 2); ctx.fill();
    ctx.fillStyle = '#eee';
    for (let i = 0; i < 5; i++) ctx.fillRect(cx - 6 + i * 3, topY + 14, 2, 2);

    // „Éú„ÇπHP„Éê„Éº
    const barW = bw + 10, barH = 5;
    const barX = -barW / 2, barY = topY - 14;
    ctx.fillStyle = '#0008';
    roundRect(barX - 1, barY - 1, barW + 2, barH + 2, 3); ctx.fill();
    ctx.fillStyle = '#333';
    roundRect(barX, barY, barW, barH, 2); ctx.fill();
    const hpRatio = hp / maxHp;
    const hpColor = hpRatio > 0.5 ? '#4f4' : hpRatio > 0.25 ? '#ff0' : '#f44';
    const hpG = ctx.createLinearGradient(barX, barY, barX, barY + barH);
    hpG.addColorStop(0, hpColor);
    hpG.addColorStop(1, hpRatio > 0.5 ? '#2a2' : '#a00');
    ctx.fillStyle = hpG;
    roundRect(barX, barY, barW * hpRatio, barH, 2); ctx.fill();
    ctx.fillStyle = '#fff3';
    roundRect(barX, barY, barW * hpRatio, barH / 2, 2); ctx.fill();

    ctx.restore();
}

function drawSpike(x, y, w, h) {
    ctx.beginPath();
    ctx.moveTo(x, y + h); ctx.lineTo(x + w / 2, y); ctx.lineTo(x + w, y + h);
    ctx.closePath(); ctx.fill();
}

// ---------- ÂºæÊèèÁîª ----------
function drawBullet(x, y, size, color) {
    const sz = size || 6;
    const c = color || '#ff4444';
    ctx.fillStyle = c + '33';
    ctx.beginPath(); ctx.arc(x, y, sz * 2, 0, Math.PI * 2); ctx.fill();
    const g = ctx.createRadialGradient(x, y, 0, x, y, sz);
    g.addColorStop(0, '#fff'); g.addColorStop(0.5, c); g.addColorStop(1, c + '00');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.fill();
}

// ---------- ËÉåÊôØÊèèÁîª ----------
let gameTime = 0;

function drawBG_sky() {
    const grad = ctx.createLinearGradient(0, 0, 0, CH);
    grad.addColorStop(0, '#060620');
    grad.addColorStop(0.5, '#0c0c40');
    grad.addColorStop(1, '#161660');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CW, CH);

    // Êòü
    for (let i = 0; i < 40; i++) {
        const sx = ((i * 173.7 + 50) % CW);
        const sy = ((i * 91.3 + 30) % (CH * 0.7));
        const twinkle = 0.4 + 0.6 * Math.sin(gameTime * 2 + i * 0.7);
        ctx.globalAlpha = twinkle * 0.7;
        ctx.fillStyle = '#fff';
        const sz = 1 + ((i * 7) % 3) * 0.5;
        ctx.beginPath(); ctx.arc(sx, sy, sz, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // ÈÅ†„ÅÑÂ±±
    ctx.fillStyle = '#0e0e3a';
    ctx.beginPath(); ctx.moveTo(0, CH);
    for (let xp = 0; xp <= CW; xp += 4) {
        const h = Math.sin(xp * 0.008) * 40 + Math.sin(xp * 0.015) * 20 + 50;
        ctx.lineTo(xp, CH - 80 - h);
    }
    ctx.lineTo(CW, CH); ctx.closePath(); ctx.fill();

    // Ëøë„ÅÑÂ±±
    ctx.fillStyle = '#121248';
    ctx.beginPath(); ctx.moveTo(0, CH);
    for (let xp = 0; xp <= CW; xp += 4) {
        const h = Math.sin(xp * 0.012) * 30 + Math.sin(xp * 0.025) * 15 + 30;
        ctx.lineTo(xp, CH - 50 - h);
    }
    ctx.lineTo(CW, CH); ctx.closePath(); ctx.fill();
}

function drawBG_skyWithScroll(camX) {
    const grad = ctx.createLinearGradient(0, 0, 0, CH);
    grad.addColorStop(0, '#060620');
    grad.addColorStop(0.5, '#0c0c40');
    grad.addColorStop(1, '#161660');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CW, CH);

    // ÊòüÔºà„Éë„É©„É©„ÉÉ„ÇØ„ÇπÔºâ
    for (let i = 0; i < 50; i++) {
        const sx = ((i * 173.7 + 50) % (CW * 3)) - (camX || 0) * 0.05;
        const sy = ((i * 91.3 + 30) % (CH * 0.6));
        if (sx < -5 || sx > CW + 5) continue;
        const twinkle = 0.4 + 0.6 * Math.sin(gameTime * 2 + i * 0.7);
        ctx.globalAlpha = twinkle * 0.7;
        ctx.fillStyle = '#fff';
        const sz = 1 + ((i * 7) % 3) * 0.5;
        ctx.beginPath(); ctx.arc(sx, sy, sz, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // ÈÅ†„ÅÑÂ±±Ôºà„Éë„É©„É©„ÉÉ„ÇØ„ÇπÔºâ
    ctx.fillStyle = '#0e0e3a';
    ctx.beginPath(); ctx.moveTo(0, CH);
    for (let xp = 0; xp <= CW; xp += 4) {
        const worldX = xp + (camX || 0) * 0.15;
        const h = Math.sin(worldX * 0.003) * 60 + Math.sin(worldX * 0.007) * 30 + Math.sin(worldX * 0.001) * 80;
        ctx.lineTo(xp, CH - 120 - h);
    }
    ctx.lineTo(CW, CH); ctx.closePath(); ctx.fill();

    // Ëøë„ÅÑÂ±±
    ctx.fillStyle = '#121248';
    ctx.beginPath(); ctx.moveTo(0, CH);
    for (let xp = 0; xp <= CW; xp += 4) {
        const worldX = xp + (camX || 0) * 0.3;
        const h = Math.sin(worldX * 0.005) * 40 + Math.sin(worldX * 0.011) * 25 + Math.sin(worldX * 0.002) * 50;
        ctx.lineTo(xp, CH - 80 - h);
    }
    ctx.lineTo(CW, CH); ctx.closePath(); ctx.fill();

    // „Éì„É´„Ç∑„É´„Ç®„ÉÉ„Éà
    ctx.fillStyle = '#161650';
    for (let i = 0; i < 20; i++) {
        const bx = ((i * 127) % (CW * 3)) - (camX || 0) * 0.4;
        const bw = 15 + ((i * 31) % 30);
        const bh = 30 + ((i * 53) % 80);
        if (bx > -bw && bx < CW + bw) {
            roundRect(bx, CH - 50 - bh, bw, bh + 50, 2); ctx.fill();
            ctx.fillStyle = '#ffee4422';
            for (let wy = CH - 40 - bh; wy < CH - 50; wy += 12) {
                for (let wx = bx + 4; wx < bx + bw - 4; wx += 8) {
                    if ((wx * wy * i) % 5 > 1) ctx.fillRect(wx, wy, 3, 4);
                }
            }
            ctx.fillStyle = '#161650';
        }
    }
}

function drawGround(groundY) {
    const gy = groundY || CH * 0.82;
    const tg = ctx.createLinearGradient(0, gy, 0, CH);
    tg.addColorStop(0, '#6b7a90');
    tg.addColorStop(0.05, '#4a5568');
    tg.addColorStop(1, '#3a4558');
    ctx.fillStyle = tg;
    ctx.fillRect(0, gy, CW, CH - gy);
    ctx.fillStyle = '#8a9ab0';
    ctx.fillRect(0, gy, CW, 3);
}

// ---------- „Çø„Ç§„É´ÊèèÁîª ----------
function drawTiles(tileMap, camX, tileSize) {
    const TILE = tileSize || 32;
    const startCol = Math.floor(camX / TILE) - 1;
    const endCol = Math.ceil((camX + CW) / TILE) + 1;
    for (let row = 0; row < tileMap.length; row++) {
        for (let col = startCol; col <= endCol && col < tileMap[row].length; col++) {
            if (col < 0) continue;
            if (tileMap[row][col] === 'B') {
                const tx = col * TILE - camX, ty = row * TILE;
                const above = row > 0 && tileMap[row - 1][col] === 'B';
                const below = row < tileMap.length - 1 && tileMap[row + 1][col] === 'B';
                const left = col > 0 && tileMap[row][col - 1] === 'B';
                const right = col < tileMap[row].length - 1 && tileMap[row][col + 1] === 'B';

                const tg = ctx.createLinearGradient(tx, ty, tx, ty + TILE);
                tg.addColorStop(0, above ? '#4a5568' : '#6b7a90');
                tg.addColorStop(1, '#3a4558');
                ctx.fillStyle = tg;
                ctx.fillRect(tx, ty, TILE, TILE);

                if (!above) {
                    ctx.fillStyle = '#8a9ab0';
                    ctx.fillRect(tx, ty, TILE, 2);
                    ctx.fillStyle = '#7a8aa044';
                    ctx.fillRect(tx, ty + 2, TILE, 4);
                }
                if (!below) {
                    ctx.fillStyle = '#2a3548';
                    ctx.fillRect(tx, ty + TILE - 2, TILE, 2);
                }
                if (!left) {
                    ctx.fillStyle = '#7a8aa044';
                    ctx.fillRect(tx, ty, 2, TILE);
                }
                if (!right) {
                    ctx.fillStyle = '#2a354844';
                    ctx.fillRect(tx + TILE - 2, ty, 2, TILE);
                }
                ctx.strokeStyle = '#4a556844';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(tx + 4, ty + 4, TILE - 8, TILE - 8);
            }
        }
    }
}

// ---------- „Ç¢„Ç§„ÉÜ„É†ÊèèÁîª ----------
function drawItem(x, y, type, bobPhase) {
    const big = type === 'hpBig';
    const sz = big ? 20 : 16;
    const iy = y + Math.sin(bobPhase || 0) * 4;

    ctx.fillStyle = big ? 'rgba(80,255,200,0.15)' : 'rgba(80,255,80,0.12)';
    ctx.beginPath(); ctx.arc(x + sz / 2, iy + sz / 2, sz, 0, Math.PI * 2); ctx.fill();

    const cg = ctx.createRadialGradient(x + sz / 2, iy + sz / 2, 1, x + sz / 2, iy + sz / 2, sz / 2);
    cg.addColorStop(0, big ? '#8ff' : '#8f8');
    cg.addColorStop(1, big ? '#2aa' : '#2a2');
    ctx.fillStyle = cg;
    roundRect(x, iy, sz, sz, sz / 4); ctx.fill();

    ctx.fillStyle = '#fff';
    const cw = big ? 4 : 3, ch = big ? 12 : 8;
    roundRect(x + sz / 2 - cw / 2, iy + sz / 2 - ch / 2, cw, ch, 1); ctx.fill();
    roundRect(x + sz / 2 - ch / 2, iy + sz / 2 - cw / 2, ch, cw, 1); ctx.fill();

    ctx.fillStyle = '#fff4';
    ctx.beginPath(); ctx.arc(x + sz * 0.35, iy + sz * 0.3, sz * 0.15, 0, Math.PI * 2); ctx.fill();
}

// ---------- „Éë„Éº„ÉÜ„Ç£„ÇØ„É´„Ç∑„Çπ„ÉÜ„É† ----------
let particles = [];

function spawnParticles(x, y, color, count, opts) {
    opts = opts || {};
    for (let i = 0; i < count; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * (opts.spread || 6),
            vy: (Math.random() - 0.5) * (opts.spread || 6) - (opts.upward || 2),
            life: opts.life || (20 + Math.random() * 20),
            maxLife: opts.life || (20 + Math.random() * 20),
            color,
            size: opts.size || (2 + Math.random() * 3),
            type: opts.type || 'square',
            rotation: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 0.2
        });
    }
}

function spawnExplosion(x, y) {
    const colors = ['#fff', '#ffe066', '#ff8844', '#ff4444', '#44aaff'];
    for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 5;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1,
            life: 20 + Math.random() * 30,
            maxLife: 20 + Math.random() * 30,
            color: colors[Math.floor(Math.random() * colors.length)],
            size: 3 + Math.random() * 6,
            type: 'circle', rotation: 0, rotSpeed: 0
        });
    }
}

function updateParticles() {
    for (const p of particles) {
        p.x += p.vx; p.y += p.vy;
        p.vy += 0.08; p.life--;
        p.size *= 0.98;
        p.rotation += p.rotSpeed;
        p.vx *= 0.98; p.vy *= 0.98;
    }
    particles = particles.filter(p => p.life > 0);
}

function drawParticles(camX) {
    const cx = camX || 0;
    for (const p of particles) {
        const px = p.x - cx;
        const alpha = clamp(p.life / p.maxLife, 0, 1);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        if (p.type === 'circle') {
            ctx.beginPath(); ctx.arc(px, p.y, p.size, 0, Math.PI * 2); ctx.fill();
        } else {
            ctx.save();
            ctx.translate(px, p.y);
            ctx.rotate(p.rotation);
            ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
            ctx.restore();
        }
    }
    ctx.globalAlpha = 1;
}

// ======================================================
// „Ç≤„Éº„É†ÁµÇ‰∫Ü
// ======================================================
function endGame() {
    stopTimer();
    hideInstruction();
    if (animId) { cancelAnimationFrame(animId); animId = null; }

    const isNew = G.score > highScore;
    if (isNew) {
        highScore = G.score;
        localStorage.setItem('microBattleHigh', highScore);
        document.getElementById('best-score').textContent = highScore.toLocaleString();
    }

    const result = document.getElementById('result');
    result.className = 'screen lose-bg';

    document.getElementById('result-content').innerHTML = `
        ${isNew ? '<div class="highscore-badge">üéâ NEW HIGH SCORE!</div>' : ''}
        <div class="result-icon-container">
            <div class="icon-ring"></div>
            <div class="result-icon">${isNew ? 'üèÜ' : 'üíÄ'}</div>
        </div>
        <div class="result-title">GAME OVER</div>
        <div class="result-score-box">
            <div class="result-score-label">Total Score</div>
            <div class="result-score-value" id="score-counter">0</div>
        </div>
        <div class="result-stats">
            <div class="stat-row">
                <span>üéØ Âà∞ÈÅî„É©„Ç¶„É≥„Éâ</span>
                <span class="stat-value cyan">${G.round}</span>
            </div>
            <div class="stat-row">
                <span>üî• ÊúÄÂ§ß„Ç≥„É≥„Éú</span>
                <span class="stat-value gold">${G.maxCombo}</span>
            </div>
            <div class="stat-row">
                <span>‚úÖ ÊàêÂäüÊï∞</span>
                <span class="stat-value cyan">${G.wins}</span>
            </div>
            <div class="stat-row">
                <span>‚ö° ÊúÄÁµÇ„Çπ„Éî„Éº„Éâ</span>
                <span class="stat-value gold">${'‚òÖ'.repeat(G.speedLevel)}${'‚òÜ'.repeat(5 - G.speedLevel)}</span>
            </div>
            <div class="stat-row">
                <span>üèÜ „Éè„Ç§„Çπ„Ç≥„Ç¢</span>
                <span class="stat-value pink">${highScore.toLocaleString()}</span>
            </div>
        </div>
        <div class="result-buttons">
            <button class="btn" onclick="startGame()">üîÑ RETRY</button>
            <button class="btn btn-cyan btn-small" onclick="showScreen('title')">üè† TITLE</button>
        </div>
    `;

    showScreen('result');

    let current = 0;
    const target = G.score;
    const step = target / (1500 / 16);
    const counter = document.getElementById('score-counter');
    const countUp = setInterval(() => {
        current += step;
        if (current >= target) { current = target; clearInterval(countUp); }
        counter.textContent = Math.floor(current).toLocaleString();
    }, 16);

    if (isNew) createConfetti();
}

function createConfetti() {
    const container = document.getElementById('confetti');
    container.innerHTML = '';
    const shapes = ['‚ñ†', '‚óè', '‚ñ≤', '‚òÖ', '‚óÜ'];
    const colors = ['#ff0066', '#00ffff', '#ffff00', '#ff00ff', '#00ff88', '#ff8800'];
    for (let i = 0; i < 60; i++) {
        const c = document.createElement('div');
        c.className = 'confetti';
        c.textContent = shapes[Math.floor(Math.random() * shapes.length)];
        c.style.left = Math.random() * 100 + '%';
        c.style.color = colors[Math.floor(Math.random() * colors.length)];
        c.style.fontSize = (10 + Math.random() * 12) + 'px';
        c.style.animationDuration = (2 + Math.random() * 3) + 's';
        c.style.animationDelay = Math.random() * 2 + 's';
        c.style.textShadow = `0 0 10px ${c.style.color}`;
        container.appendChild(c);
    }
}

// ======================================================
// „Éü„Éã„Ç≤„Éº„É†ÂÆöÁæ©Ôºà11Á®ÆÈ°ûÔºâ
// ======================================================
const MINIGAMES = [
    MG_ShootEnemy,
    MG_DodgeBullets,
    MG_CatchItems,
    MG_TapTarget,
    MG_SlashEnemy,
    MG_JumpGap,
    MG_FindDifferent,
    MG_MemoryFlash,
    MG_SwipeDirection,
    MG_RapidTap,
    MG_SideScrollAction,
];

// ======================================================
// 1. „ÅÜ„Å¶ÔºÅ - „Çø„ÉÉ„Éó„ÅßÂºæ„ÇíÊíÉ„Å£„Å¶Êïµ„ÇíÂÄí„Åô
// ======================================================
function MG_ShootEnemy() {
    let enemy, bullets, frame, pState;

    return {
        instruction: 'üî´ „ÅÜ„Å¶ÔºÅ',
        start() {
            frame = 0;
            bullets = [];
            pState = {
                x: CW * 0.12, y: CH * 0.68,
                facing: 1, walkPhase: 0, shootTimer: 0,
                invincible: 0, armAngle: 0, landSquash: 0,
                jumpStretch: 0, eyeBlink: 120
            };
            const types = ['met', 'sniper', 'fly'];
            const t = types[Math.floor(Math.random() * types.length)];
            enemy = {
                x: CW * 0.55 + Math.random() * CW * 0.3,
                y: t === 'fly' ? CH * 0.3 + Math.random() * CH * 0.15 : CH * 0.65,
                type: t,
                hp: t === 'fly' ? 1 : 2,
                alive: true,
                vx: (Math.random() - 0.5) * 1.5,
                baseY: CH * 0.35,
                flash: 0,
                dir: -1,
                hiding: false
            };
        },
        onDown(x, y) {
            const dx = x - (pState.x + 11);
            const dy = y - (pState.y + 10);
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const speed = 7 + G.speedLevel;
            bullets.push({
                x: pState.x + 22, y: pState.y + 10,
                vx: dx / len * speed, vy: dy / len * speed,
                alive: true
            });
            pState.shootTimer = 10;
            pState.armAngle = 0.3;
            if (dx < 0) pState.facing = -1;
            else pState.facing = 1;
        },
        update() {
            frame++;
            gameTime = frame / 60;
            if (pState.shootTimer > 0) pState.shootTimer--;
            pState.armAngle *= 0.85;
            pState.eyeBlink--;
            if (pState.eyeBlink <= 0) pState.eyeBlink = 120 + Math.random() * 180;

            if (!enemy.alive) return;

            if (enemy.type === 'fly') {
                enemy.x += Math.sin(frame * 0.05) * 1.5;
                enemy.y = enemy.baseY + Math.sin(frame * 0.04) * 30;
            } else {
                enemy.x += enemy.vx;
                if (enemy.x < CW * 0.3 || enemy.x > CW * 0.85) enemy.vx *= -1;
            }
            if (enemy.flash > 0) enemy.flash--;

            for (let b of bullets) {
                if (!b.alive) continue;
                b.x += b.vx;
                b.y += b.vy;
                if (b.x < -10 || b.x > CW + 10 || b.y < -10 || b.y > CH + 10) {
                    b.alive = false; continue;
                }
                if (enemy.alive) {
                    const dx = b.x - enemy.x, dy = b.y - enemy.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 22) {
                        enemy.hp--;
                        enemy.flash = 8;
                        b.alive = false;
                        spawnParticles(b.x, b.y, '#fff', 6, { spread: 4, life: 10 });
                        if (enemy.hp <= 0) {
                            enemy.alive = false;
                            spawnExplosion(enemy.x, enemy.y);
                            setTimeout(() => miniGameWin(), 200);
                        }
                    }
                }
            }
            bullets = bullets.filter(b => b.alive);
            updateParticles();
        },
        draw() {
            drawBG_sky();
            drawGround(CH * 0.78);

            drawPlayer(pState.x, pState.y, pState.facing, pState.walkPhase,
                true, pState.shootTimer, pState.invincible, pState.armAngle,
                pState.landSquash, pState.jumpStretch, pState.eyeBlink);

            if (enemy.alive) {
                ctx.globalAlpha = (enemy.flash > 0 && enemy.flash % 2 === 0) ? 0.4 : 1;
                if (enemy.type === 'met') drawMet(enemy.x, enemy.y, false);
                else if (enemy.type === 'sniper') drawSniper(enemy.x, enemy.y, enemy.dir);
                else drawFlyEnemy(enemy.x, enemy.y, frame);
                ctx.globalAlpha = 1;
            }

            for (let b of bullets) {
                drawBullet(b.x, b.y, 5, '#44aaff');
            }
            drawParticles(0);
        }
    };
}

// ======================================================
// 2. „Çà„Åë„ÇçÔºÅ - ÂºæÂπï„Çí‰∏ÄÂÆöÊôÇÈñìÈÅø„Åë„Çã
// ======================================================
function MG_DodgeBullets() {
    let px, py, bullets, frame, survived, needFrames;

    return {
        instruction: 'üí® „Çà„Åë„ÇçÔºÅ',
        start() {
            px = CW / 2; py = CH * 0.65;
            bullets = []; frame = 0; survived = false;
            needFrames = 80 + G.speedLevel * 8;
        },
        onDown(x, y) { px = x; py = y; },
        onMove(x, y) { if (touchState.down) { px = x; py = y; } },
        update() {
            frame++;
            gameTime = frame / 60;
            const rate = Math.max(4, 14 - G.speedLevel * 2);
            if (frame % rate === 0) {
                const side = Math.random();
                let bx, by, bvx, bvy;
                if (side < 0.33) {
                    bx = Math.random() * CW; by = -10;
                    bvx = (Math.random() - 0.5) * 2; bvy = 2 + Math.random() * 2;
                } else if (side < 0.66) {
                    bx = -10; by = Math.random() * CH * 0.6;
                    bvx = 2 + Math.random() * 2; bvy = (Math.random() - 0.5) * 2;
                } else {
                    bx = CW + 10; by = Math.random() * CH * 0.6;
                    bvx = -(2 + Math.random() * 2); bvy = (Math.random() - 0.5) * 2;
                }
                bullets.push({ x: bx, y: by, vx: bvx, vy: bvy });
            }
            for (let b of bullets) {
                b.x += b.vx; b.y += b.vy;
                const dx = b.x - px, dy = b.y - py;
                if (Math.sqrt(dx * dx + dy * dy) < 14) {
                    miniGameFail(); return;
                }
            }
            bullets = bullets.filter(b =>
                b.x > -30 && b.x < CW + 30 && b.y > -30 && b.y < CH + 30);
            if (frame >= needFrames && !survived) {
                survived = true;
                miniGameWin();
            }
        },
        draw() {
            drawBG_sky();
            drawPlayer(px - 11, py - 15, 1, 0, true, 0, 0, 0, 0, 0, 999);
            ctx.strokeStyle = 'rgba(0,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(px, py, 14, 0, Math.PI * 2); ctx.stroke();
            for (let b of bullets) {
                drawBullet(b.x, b.y, 5, '#ff4444');
            }
            const remain = Math.max(0, needFrames - frame);
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${CW * 0.06}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(`„ÅÇ„Å® ${(remain / 60).toFixed(1)}s`, CW / 2, CH * 0.12);
        }
    };
}

// ======================================================
// 3. „Å®„ÇåÔºÅ - ËêΩ„Å°„Å¶„Åè„Çã„Ç¢„Ç§„ÉÜ„É†„Çí„Ç≠„É£„ÉÉ„ÉÅ
// ======================================================
function MG_CatchItems() {
    let px, items, frame, caught, need;

    return {
        instruction: 'üéÅ „Å®„ÇåÔºÅ',
        start() {
            px = CW / 2;
            items = []; frame = 0; caught = 0; need = 3;
        },
        onDown(x) { px = x; },
        onMove(x) { if (touchState.down) px = x; },
        update() {
            frame++;
            gameTime = frame / 60;
            const rate = Math.max(12, 35 - G.speedLevel * 5);
            if (frame % rate === 0) {
                items.push({
                    x: Math.random() * (CW - 40) + 20,
                    y: -20,
                    type: Math.random() < 0.3 ? 'hpBig' : 'hpSmall',
                    alive: true,
                    bobPhase: Math.random() * 6
                });
            }
            const pY = CH * 0.78;
            const pW = 28;
            for (let item of items) {
                item.y += 3 + G.speedLevel * 0.5;
                item.bobPhase += 0.06;
                if (item.alive && item.y > pY - 20 && item.y < pY + 20 &&
                    Math.abs(item.x - px) < pW) {
                    item.alive = false;
                    caught++;
                    spawnParticles(item.x, item.y, '#4f4', 8, { spread: 4, life: 12 });
                    if (caught >= need) {
                        miniGameWin(); return;
                    }
                }
                if (item.y > CH + 20) item.alive = false;
            }
            items = items.filter(i => i.alive);
            updateParticles();
        },
        draw() {
            drawBG_sky();
            drawGround(CH * 0.82);
            drawPlayer(px - 11, CH * 0.72, 1, frame * 0.01, true, 0, 0, 0, 0, 0, 999);
            for (let item of items) {
                drawItem(item.x - 8, item.y - 8, item.type, item.bobPhase);
            }
            drawParticles(0);
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${CW * 0.06}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(`${caught} / ${need}`, CW / 2, CH * 0.1);
        }
    };
}

// ======================================================
// 4. „Çø„ÉÉ„ÉóÔºÅ - Êïµ„Çí„Çø„ÉÉ„Éó„Åó„Å¶ÂÄí„Åô
// ======================================================
function MG_TapTarget() {
    let targets, frame, tapped, need;

    function spawnTarget() {
        const r = CW * 0.06 + 8;
        targets.push({
            x: r + Math.random() * (CW - r * 2),
            y: CH * 0.18 + Math.random() * (CH * 0.55),
            r, alive: true, pulse: 0,
            type: ['met', 'sniper', 'fly'][Math.floor(Math.random() * 3)]
        });
    }

    return {
        instruction: 'üëÜ „Çø„ÉÉ„ÉóÔºÅ',
        start() {
            targets = []; frame = 0; tapped = 0; need = 3;
            spawnTarget();
        },
        onDown(x, y) {
            for (let t of targets) {
                if (!t.alive) continue;
                const dx = x - t.x, dy = y - t.y;
                if (Math.sqrt(dx * dx + dy * dy) < t.r + 15) {
                    t.alive = false;
                    tapped++;
                    spawnExplosion(t.x, t.y);
                    if (tapped >= need) {
                        miniGameWin(); return;
                    }
                    setTimeout(spawnTarget, 100);
                }
            }
        },
        update() {
            frame++;
            gameTime = frame / 60;
            for (let t of targets) {
                if (t.alive) t.pulse += 0.1;
            }
            updateParticles();
        },
        draw() {
            drawBG_sky();
            for (let t of targets) {
                if (!t.alive) continue;
                ctx.strokeStyle = '#ff008866';
                ctx.lineWidth = 2;
                const pr = t.r + Math.sin(t.pulse) * 4;
                ctx.beginPath(); ctx.arc(t.x, t.y, pr + 8, 0, Math.PI * 2); ctx.stroke();

                if (t.type === 'met') drawMet(t.x, t.y, false);
                else if (t.type === 'sniper') drawSniper(t.x, t.y, -1);
                else drawFlyEnemy(t.x, t.y, frame);
            }
            drawParticles(0);
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${CW * 0.06}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(`${tapped} / ${need}`, CW / 2, CH * 0.08);
        }
    };
}

// ======================================================
// 5. „Åç„ÇåÔºÅ - „Çπ„ÉØ„Ç§„Éó„ÅßÊïµ„ÇíÊñ¨„Çã
// ======================================================
function MG_SlashEnemy() {
    let enemies, frame, slashed, slashTrail, need;

    return {
        instruction: '‚öîÔ∏è „Åç„ÇåÔºÅ',
        start() {
            enemies = []; need = 3; frame = 0; slashed = 0;
            slashTrail = [];
            for (let i = 0; i < need; i++) {
                enemies.push({
                    x: CW * 0.15 + Math.random() * CW * 0.7,
                    y: CH * 0.2 + Math.random() * CH * 0.5,
                    alive: true,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 1.5,
                    type: ['met', 'sniper'][Math.floor(Math.random() * 2)],
                    dir: Math.random() < 0.5 ? 1 : -1
                });
            }
        },
        onDown(x, y) { slashTrail = [{ x, y }]; },
        onMove(x, y) {
            if (!touchState.down) return;
            slashTrail.push({ x, y });
            if (slashTrail.length > 25) slashTrail.shift();
            for (let e of enemies) {
                if (!e.alive) continue;
                const dx = x - e.x, dy = y - e.y;
                if (Math.sqrt(dx * dx + dy * dy) < 28 && slashTrail.length > 3) {
                    e.alive = false;
                    slashed++;
                    spawnExplosion(e.x, e.y);
                    if (slashed >= need) miniGameWin();
                }
            }
        },
        onUp() { slashTrail = []; },
        update() {
            frame++;
            gameTime = frame / 60;
            for (let e of enemies) {
                if (!e.alive) continue;
                e.x += e.vx; e.y += e.vy;
                if (e.x < 25 || e.x > CW - 25) e.vx *= -1;
                if (e.y < CH * 0.12 || e.y > CH - 40) e.vy *= -1;
            }
            updateParticles();
        },
        draw() {
            drawBG_sky();
            for (let e of enemies) {
                if (!e.alive) continue;
                if (e.type === 'met') drawMet(e.x, e.y, false);
                else drawSniper(e.x, e.y, e.dir);
            }
            if (slashTrail.length > 1) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(slashTrail[0].x, slashTrail[0].y);
                for (let i = 1; i < slashTrail.length; i++) {
                    ctx.lineTo(slashTrail[i].x, slashTrail[i].y);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            drawParticles(0);
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${CW * 0.06}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(`${slashed} / ${need}`, CW / 2, CH * 0.08);
        }
    };
}

// ======================================================
// 6. „Å®„ÅπÔºÅ - „Çø„ÉÉ„Éó„Åß„Ç∏„É£„É≥„Éó„Åó„Å¶Á©¥„ÇíË∂ä„Åà„Çã
// ======================================================
function MG_JumpGap() {
    let px, py, vy, grounded, scrollX, gapX, gapW, cleared, failed;
    const speed = 3 + G.speedLevel * 0.5;
    const gravity = 0.5 + G.speedLevel * 0.05;

    return {
        instruction: 'ü¶ò „Å®„ÅπÔºÅ',
        start() {
            px = CW * 0.18; py = 0; vy = 0;
            grounded = true; scrollX = 0;
            gapX = CW * 0.9;
            gapW = CW * 0.22 + G.speedLevel * 6;
            cleared = false; failed = false;

            const groundY = CH * 0.78;
            py = groundY - 30;
        },
        onDown() {
            if (grounded && !cleared && !failed) {
                vy = -(10 + G.speedLevel * 0.5);
                grounded = false;
            }
        },
        update() {
            if (cleared || failed) return;
            gameTime += 1 / 60;
            scrollX += speed;
            vy += gravity;
            py += vy;

            const groundY = CH * 0.78;
            const worldPx = px + scrollX;
            const inGap = worldPx > gapX && worldPx < gapX + gapW;

            if (!inGap && py >= groundY - 30) {
                py = groundY - 30;
                vy = 0;
                grounded = true;
                if (worldPx > gapX + gapW && !cleared) {
                    cleared = true;
                    setTimeout(() => miniGameWin(), 200);
                }
            }
            if (py > CH + 50 && !failed) {
                failed = true;
                miniGameFail();
            }
        },
        draw() {
            drawBG_sky();
            const groundY = CH * 0.78;
            const gapScreenX = gapX - scrollX;

            ctx.fillStyle = '#4a5568';
            ctx.fillRect(0, groundY, Math.max(0, gapScreenX), CH - groundY);
            ctx.fillRect(gapScreenX + gapW, groundY, CW - gapScreenX - gapW, CH - groundY);
            ctx.fillStyle = '#8a9ab0';
            ctx.fillRect(0, groundY, Math.max(0, gapScreenX), 3);
            if (gapScreenX + gapW < CW)
                ctx.fillRect(gapScreenX + gapW, groundY, CW - gapScreenX - gapW, 3);

            ctx.fillStyle = 'rgba(255,0,0,0.12)';
            ctx.fillRect(gapScreenX, groundY, gapW, CH - groundY);
            ctx.fillStyle = '#ff4444';
            for (let i = 0; i < gapW; i += 15) {
                const sx = gapScreenX + i;
                ctx.beginPath();
                ctx.moveTo(sx, CH); ctx.lineTo(sx + 7, CH - 12); ctx.lineTo(sx + 14, CH);
                ctx.fill();
            }

            drawPlayer(px, py, 1, grounded ? scrollX * 0.05 : 0,
                grounded, 0, 0, 0, 0, grounded ? 0 : 0.3, 999);
        }
    };
}

// ======================================================
// 7. „Åø„Å§„Åë„ÇçÔºÅ - ÈÅï„ÅÜÊïµ„ÇíË¶ã„Å§„Åë„Å¶„Çø„ÉÉ„Éó
// ======================================================
function MG_FindDifferent() {
    let grid, diffIdx, found, frame;
    const cols = 3, rows = 3;

    return {
        instruction: 'üîç „Åø„Å§„Åë„ÇçÔºÅ',
        start() {
            const types = ['met', 'sniper', 'fly'];
            const mainType = types[Math.floor(Math.random() * types.length)];
            let diffType;
            do { diffType = types[Math.floor(Math.random() * types.length)]; }
            while (diffType === mainType);
            grid = [];
            diffIdx = Math.floor(Math.random() * (cols * rows));
            for (let i = 0; i < cols * rows; i++) {
                grid.push(i === diffIdx ? diffType : mainType);
            }
            found = false; frame = 0;
        },
        onDown(x, y) {
            if (found) return;
            const cellW = CW / cols;
            const cellH = (CH * 0.65) / rows;
            const offY = CH * 0.18;
            const col = Math.floor(x / cellW);
            const row = Math.floor((y - offY) / cellH);
            if (col < 0 || col >= cols || row < 0 || row >= rows) return;
            const idx = row * cols + col;
            if (idx === diffIdx) {
                found = true;
                spawnExplosion(x, y);
                miniGameWin();
            } else {
                miniGameFail();
            }
        },
        update() {
            frame++;
            gameTime = frame / 60;
            updateParticles();
        },
        draw() {
            drawBG_sky();
            const cellW = CW / cols;
            const cellH = (CH * 0.65) / rows;
            const offY = CH * 0.18;
            for (let i = 0; i < grid.length; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const cx = col * cellW + cellW / 2;
                const cy = offY + row * cellH + cellH / 2;

                ctx.fillStyle = (i === diffIdx && found)
                    ? 'rgba(0,255,100,0.2)' : 'rgba(255,255,255,0.05)';
                roundRect(col * cellW + 4, offY + row * cellH + 4,
                    cellW - 8, cellH - 8, 8);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1; ctx.stroke();

                if (grid[i] === 'met') drawMet(cx, cy, false);
                else if (grid[i] === 'sniper') drawSniper(cx, cy, -1);
                else drawFlyEnemy(cx, cy, frame);
            }
            drawParticles(0);
        }
    };
}

// ======================================================
// 8. „Åä„Åº„Åà„ÇçÔºÅ - ÂÖâ„Å£„ÅüÈ†ÜÁï™„Çí„Çø„ÉÉ„Éó
// ======================================================
function MG_MemoryFlash() {
    let sequence, playerSeq, phase, showIdx, showTimer, cells;
    const numCells = 4;
    const seqLen = Math.min(2 + Math.floor(G.speedLevel / 2), 4);
    let frame;

    return {
        instruction: 'üß† „Åä„Åº„Åà„ÇçÔºÅ',
        start() {
            const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44'];
            const emojis = ['üî¥', 'üü¢', 'üîµ', 'üü°'];
            const w = CW / 2 - 15;
            const h = CH * 0.26;
            cells = [];
            for (let i = 0; i < numCells; i++) {
                const col = i % 2, row = Math.floor(i / 2);
                cells.push({
                    x: 10 + col * (w + 10),
                    y: CH * 0.2 + row * (h + 10),
                    w, h,
                    color: colors[i], emoji: emojis[i], lit: false
                });
            }
            sequence = [];
            for (let i = 0; i < seqLen; i++) {
                sequence.push(Math.floor(Math.random() * numCells));
            }
            playerSeq = [];
            phase = 'showing'; showIdx = 0; showTimer = 0; frame = 0;
        },
        onDown(x, y) {
            if (phase !== 'input') return;
            for (let i = 0; i < cells.length; i++) {
                const c = cells[i];
                if (x >= c.x && x <= c.x + c.w && y >= c.y && y <= c.y + c.h) {
                    c.lit = true;
                    setTimeout(() => c.lit = false, 200);
                    playerSeq.push(i);
                    const idx = playerSeq.length - 1;
                    if (playerSeq[idx] !== sequence[idx]) {
                        miniGameFail(); return;
                    }
                    if (playerSeq.length === sequence.length) {
                        miniGameWin();
                    }
                    break;
                }
            }
        },
        update() {
            frame++;
            if (phase === 'showing') {
                showTimer++;
                const speed = Math.max(15, 30 - G.speedLevel * 3);
                if (showTimer < speed) {
                    cells[sequence[showIdx]].lit = true;
                } else if (showTimer < speed + 10) {
                    cells[sequence[showIdx]].lit = false;
                } else {
                    showTimer = 0;
                    showIdx++;
                    if (showIdx >= sequence.length) phase = 'input';
                }
            }
        },
        draw() {
            drawBG_sky();
            for (let c of cells) {
                ctx.fillStyle = c.lit ? c.color : c.color + '44';
                roundRect(c.x, c.y, c.w, c.h, 12); ctx.fill();
                ctx.strokeStyle = c.color; ctx.lineWidth = 2;
                roundRect(c.x, c.y, c.w, c.h, 12); ctx.stroke();
                if (c.lit) {
                    ctx.fillStyle = c.color + '33';
                    roundRect(c.x - 5, c.y - 5, c.w + 10, c.h + 10, 15); ctx.fill();
                }
                ctx.font = `${CW * 0.08}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(c.emoji, c.x + c.w / 2, c.y + c.h / 2 + CW * 0.03);
            }
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${CW * 0.05}px sans-serif`;
            ctx.textAlign = 'center';
            if (phase === 'showing') {
                ctx.fillText('„Åø„Å¶ÔºÅ', CW / 2, CH * 0.12);
            } else {
                ctx.fillText(`„Åä„Åó„Å¶ÔºÅ (${playerSeq.length}/${sequence.length})`, CW / 2, CH * 0.12);
            }
        }
    };
}

// ======================================================
// 9. „Çπ„ÉØ„Ç§„ÉóÔºÅ - ÊåáÂÆöÊñπÂêë„Å´„Çπ„ÉØ„Ç§„Éó
// ======================================================
function MG_SwipeDirection() {
    let direction, swiped, frame;
    const dirs = [
        { name: '‚Üí', dx: 1, dy: 0, label: '„Åø„ÅéÔºÅ' },
        { name: '‚Üê', dx: -1, dy: 0, label: '„Å≤„Å†„ÇäÔºÅ' },
        { name: '‚Üë', dx: 0, dy: -1, label: '„ÅÜ„ÅàÔºÅ' },
        { name: '‚Üì', dx: 0, dy: 1, label: '„Åó„ÅüÔºÅ' },
    ];

    return {
        instruction: 'üëâ „Çπ„ÉØ„Ç§„ÉóÔºÅ',
        start() {
            direction = dirs[Math.floor(Math.random() * dirs.length)];
            swiped = false; frame = 0;
        },
        onUp(x, y, sx, sy) {
            if (swiped) return;
            const dx = x - sx, dy = y - sy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 30) return;
            const ndx = dx / dist, ndy = dy / dist;
            const dot = ndx * direction.dx + ndy * direction.dy;
            if (dot > 0.6) { swiped = true; miniGameWin(); }
            else { swiped = true; miniGameFail(); }
        },
        update() { frame++; gameTime = frame / 60; },
        draw() {
            drawBG_sky();
            ctx.save();
            ctx.translate(CW / 2, CH / 2);
            const angle = Math.atan2(direction.dy, direction.dx);
            ctx.rotate(angle);
            const pulse = 1 + Math.sin(frame * 0.1) * 0.1;
            ctx.scale(pulse, pulse);
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            const aw = CW * 0.18;
            ctx.moveTo(aw, 0);
            ctx.lineTo(aw * 0.3, -CW * 0.1);
            ctx.lineTo(aw * 0.3, -CW * 0.04);
            ctx.lineTo(-aw * 0.6, -CW * 0.04);
            ctx.lineTo(-aw * 0.6, CW * 0.04);
            ctx.lineTo(aw * 0.3, CW * 0.04);
            ctx.lineTo(aw * 0.3, CW * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();

            ctx.fillStyle = '#fff';
            ctx.font = `bold ${CW * 0.12}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(direction.label, CW / 2, CH * 0.18);
        }
    };
}

// ======================================================
// 10. „Çå„Çì„Å†ÔºÅ - ÈÄ£Êâì„Åó„Å¶„Ç≤„Éº„Ç∏„ÇíÊ∫ú„ÇÅ„Çã
// ======================================================
function MG_RapidTap() {
    let taps, need, frame, done;

    return {
        instruction: 'üí• „Çå„Çì„Å†ÔºÅ',
        start() {
            taps = 0; frame = 0; done = false;
            need = 8 + G.speedLevel * 2;
        },
        onDown() {
            if (done) return;
            taps++;
            spawnParticles(CW * 0.5, CH * 0.4, '#ff8', 3, { spread: 5, life: 10 });
            if (taps >= need) {
                done = true;
                spawnExplosion(CW * 0.65, CH * 0.38);
                miniGameWin();
            }
        },
        update() {
            frame++;
            gameTime = frame / 60;
            updateParticles();
        },
        draw() {
            drawBG_sky();
            drawGround(CH * 0.82);

            const gauge = taps / need;
            const enemyX = CW * 0.45 + gauge * CW * 0.35;
            drawMet(enemyX, CH * 0.67, false);
            drawPlayer(CW * 0.15, CH * 0.65, 1, frame * 0.2, true,
                (frame % 6 < 3 && taps > 0) ? 8 : 0, 0, 0, 0, 0, 999);

            // „Ç≤„Éº„Ç∏„Éê„Éº
            const barW = CW * 0.7, barH = CW * 0.08;
            const bx = (CW - barW) / 2, by = CH * 0.5;
            ctx.fillStyle = '#222';
            roundRect(bx, by, barW, barH, barH / 2); ctx.fill();
            ctx.strokeStyle = '#555'; ctx.lineWidth = 2;
            roundRect(bx, by, barW, barH, barH / 2); ctx.stroke();
            const fillW = Math.min(gauge, 1) * barW;
            if (fillW > 0) {
                const fg = ctx.createLinearGradient(bx, by, bx + fillW, by);
                fg.addColorStop(0, '#ff0088'); fg.addColorStop(1, '#ff8800');
                ctx.fillStyle = fg;
                roundRect(bx, by, fillW, barH, barH / 2); ctx.fill();
            }

            drawParticles(0);

            ctx.fillStyle = '#fff';
            ctx.font = `bold ${CW * 0.05}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(`${taps} / ${need}`, CW / 2, by - 12);

            if (frame % 20 < 10) {
                ctx.fillStyle = '#ffff00';
                ctx.font = `bold ${CW * 0.1}px sans-serif`;
                ctx.fillText('TAP!', CW / 2, CH * 0.22);
            }
        }
    };
}

// ======================================================
// 11. Ê®™„Çπ„ÇØ„É≠„Éº„É´„Ç¢„ÇØ„Ç∑„Éß„É≥ÔºÅ - „Ç¥„Éº„É´„Åæ„ÅßËµ∞„Å£„Å¶„Éú„Çπ„ÇíÂÄí„Åõ
// ======================================================
function MG_SideScrollAction() {
    // „Çø„Ç§„É´„Éû„ÉÉ„ÉóÔºàÂ∞è„Åï„ÇÅÔºâ
    const TILE = Math.floor(CH / 10);
    const mapRows = 10;
    const mapData = [
        "..............................",
        "..............................",
        "..............................",
        "..............................",
        "..............................",
        ".........BB.....BB............",
        "..............................",
        "....BBB.....BBB.....BBB..BB...",
        "..........................BB..",
        "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
    ];
    const mapCols = mapData[0].length;
    const stageWidth = mapCols * TILE;

    let p, cam, enemies, eBullets, pBullets, items, pParticles, frame;
    let bossAlive, goalReached;

    function tileAt(px, py) {
        const col = Math.floor(px / TILE);
        const row = Math.floor(py / TILE);
        if (row < 0 || row >= mapRows || col < 0 || col >= mapCols) return '.';
        return mapData[row][col];
    }
    function isSolid(px, py) { return tileAt(px, py) === 'B'; }

    function resolvePhysics(obj) {
        obj.x += obj.vx;
        if (obj.vx > 0) {
            if (isSolid(obj.x + obj.w, obj.y + 2) || isSolid(obj.x + obj.w, obj.y + obj.h - 2)) {
                obj.x = Math.floor((obj.x + obj.w) / TILE) * TILE - obj.w;
                obj.vx = 0;
            }
        } else if (obj.vx < 0) {
            if (isSolid(obj.x, obj.y + 2) || isSolid(obj.x, obj.y + obj.h - 2)) {
                obj.x = Math.floor(obj.x / TILE) * TILE + TILE;
                obj.vx = 0;
            }
        }
        obj.y += obj.vy;
        obj.grounded = false;
        if (obj.vy > 0) {
            if (isSolid(obj.x + 2, obj.y + obj.h) || isSolid(obj.x + obj.w - 2, obj.y + obj.h)) {
                obj.y = Math.floor((obj.y + obj.h) / TILE) * TILE - obj.h;
                obj.vy = 0;
                obj.grounded = true;
            }
        } else if (obj.vy < 0) {
            if (isSolid(obj.x + 2, obj.y) || isSolid(obj.x + obj.w - 2, obj.y)) {
                obj.y = Math.floor(obj.y / TILE) * TILE + TILE;
                obj.vy = 0;
            }
        }
    }

    // „Éê„Éº„ÉÅ„É£„É´„Éë„ÉÉ„ÉâÁä∂ÊÖã
    let vpad = { left: false, right: false, jump: false, shoot: false };
    let lastTapTime = 0;

    return {
        instruction: 'üéÆ „Éú„Çπ„Çí„Åü„Åä„ÅõÔºÅ',
        start() {
            frame = 0;
            bossAlive = true; goalReached = false;
            pParticles = [];
            pBullets = [];
            eBullets = [];
            items = [];

            p = {
                x: TILE * 2, y: TILE * 7,
                vx: 0, vy: 0, w: 16, h: 22,
                facing: 1, grounded: false,
                walkPhase: 0, shootTimer: 0,
                invincible: 0, armAngle: 0,
                landSquash: 0, jumpStretch: 0,
                eyeBlink: 120, hp: 3, alive: true
            };

            cam = { x: 0, targetX: 0 };

            enemies = [];
            // „É°„ÉÉ„Éà
            enemies.push({
                x: TILE * 8, y: TILE * 8, w: 18, h: 16,
                type: 'met', hp: 2, alive: true, hiding: true,
                hideTimer: 60, shootTimer: 0, vx: 0, vy: 0,
                grounded: false, flash: 0, dir: -1
            });
            // „Éï„É©„Ç§
            enemies.push({
                x: TILE * 16, y: TILE * 4, w: 18, h: 18,
                type: 'fly', hp: 1, alive: true,
                baseY: TILE * 4, flyAngle: 0,
                vx: 0, vy: 0, grounded: false, flash: 0,
                shootTimer: 0, dir: -1
            });
            // „Éú„Çπ
            enemies.push({
                x: TILE * 25, y: TILE * 4, w: 36, h: 42,
                type: 'boss', hp: 6, maxHp: 6, alive: true,
                vx: 0, vy: 0, grounded: false, flash: 0,
                dir: -1, moveTimer: 0, shootTimer: 0, phase: 0
            });

            // „Ç¢„Ç§„ÉÜ„É†
            items.push({
                x: TILE * 12, y: TILE * 7.5,
                type: 'hpSmall', alive: true, bobPhase: 0
            });

            vpad = { left: false, right: false, jump: false, shoot: false };
        },

        onDown(x, y) {
            // Â∑¶ÂçäÂàÜ„Çø„ÉÉ„Éó ‚Üí ÁßªÂãïÊñπÂêëÂà§ÂÆö + „Ç∏„É£„É≥„Éó
            // Âè≥ÂçäÂàÜ„Çø„ÉÉ„Éó ‚Üí „Ç∑„É•„Éº„Éà
            // ‰∏äÂçäÂàÜ„Çø„ÉÉ„Éó ‚Üí „Ç∏„É£„É≥„Éó
            const now = Date.now();
            if (x < CW * 0.35) {
                vpad.left = true; vpad.right = false;
            } else if (x > CW * 0.65) {
                // Âè≥ÂÅ¥ = „Ç∑„É•„Éº„Éà
                vpad.shoot = true;
            } else {
                vpad.right = true; vpad.left = false;
            }
            if (y < CH * 0.5) {
                vpad.jump = true;
            }
            // „ÉÄ„Éñ„É´„Çø„ÉÉ„Éó„Åß„Ç∏„É£„É≥„Éó
            if (now - lastTapTime < 300) {
                vpad.jump = true;
            }
            lastTapTime = now;
        },
        onMove(x, y) {
            if (!touchState.down) return;
            vpad.left = false; vpad.right = false;
            if (x < CW * 0.35) vpad.left = true;
            else if (x < CW * 0.65) vpad.right = true;
            else vpad.shoot = true;
        },
        onUp() {
            vpad.left = false; vpad.right = false;
            vpad.jump = false; vpad.shoot = false;
        },

        update() {
            frame++;
            gameTime = frame / 60;
            if (!p.alive || goalReached) return;

            // „Éó„É¨„Ç§„É§„ÉºÁßªÂãï
            const moveSpd = 2.5;
            p.vx = 0;
            if (vpad.left) { p.vx = -moveSpd; p.facing = -1; }
            if (vpad.right) { p.vx = moveSpd; p.facing = 1; }

            const wasGrounded = p.grounded;
            if (vpad.jump && p.grounded) {
                p.vy = -8;
                p.grounded = false;
                p.jumpStretch = 1;
                vpad.jump = false;
            }
            if (vpad.shoot && p.shootTimer === 0 && pBullets.length < 3) {
                const bx = p.x + (p.facing > 0 ? p.w : -6);
                const by = p.y + 8;
                pBullets.push({ x: bx, y: by, vx: p.facing * 6, vy: 0, alive: true });
                p.shootTimer = 12;
                p.armAngle = p.facing * 0.3;
                vpad.shoot = false;
            }

            if (p.shootTimer > 0) p.shootTimer--;
            p.vy += 0.45;
            if (p.vy > 8) p.vy = 8;
            resolvePhysics(p);

            if (!wasGrounded && p.grounded) p.landSquash = 1;
            p.landSquash *= 0.85;
            p.jumpStretch *= 0.9;
            p.armAngle *= 0.85;
            p.eyeBlink--;
            if (p.eyeBlink <= 0) p.eyeBlink = 120 + Math.random() * 180;
            if (Math.abs(p.vx) > 0 && p.grounded) p.walkPhase += 0.15;
            if (p.invincible > 0) p.invincible--;
            if (p.x < 0) p.x = 0;
            if (p.x + p.w > stageWidth) p.x = stageWidth - p.w;
            if (p.y > mapRows * TILE + 50) {
                p.alive = false;
                miniGameFail();
                return;
            }

            // „Ç´„É°„É©
            cam.targetX = p.x - CW / 2 + p.w / 2;
            cam.x += (cam.targetX - cam.x) * 0.1;
            cam.x = clamp(cam.x, 0, stageWidth - CW);

            // „Éó„É¨„Ç§„É§„ÉºÂºæ
            for (let b of pBullets) {
                if (!b.alive) continue;
                b.x += b.vx;
                if (b.x < cam.x - 30 || b.x > cam.x + CW + 30) { b.alive = false; continue; }
                if (isSolid(b.x, b.y)) {
                    b.alive = false; continue;
                }
            }

            // Êïµ
            for (let e of enemies) {
                if (!e.alive) continue;
                if (e.flash > 0) e.flash--;
                const dist = Math.abs(e.x - p.x);

                switch (e.type) {
                    case 'met':
                        e.vy += 0.45;
                        if (e.vy > 8) e.vy = 8;
                        if (dist < 150) {
                            e.hideTimer--;
                            if (e.hideTimer <= 0) {
                                e.hiding = false;
                                e.shootTimer++;
                                if (e.shootTimer >= 50) {
                                    const dx = p.x > e.x ? 1 : -1;
                                    eBullets.push({
                                        x: e.x + e.w / 2, y: e.y + 4,
                                        vx: dx * 2.5, vy: -0.5, alive: true
                                    });
                                    e.shootTimer = 0;
                                    e.hideTimer = 80;
                                    e.hiding = true;
                                }
                            }
                        } else {
                            e.hiding = true; e.hideTimer = 30;
                        }
                        resolvePhysics(e);
                        break;

                    case 'fly':
                        e.flyAngle += 0.04;
                        e.y = e.baseY + Math.sin(e.flyAngle) * 25;
                        if (dist < 200) {
                            e.x += (p.x > e.x ? 0.7 : -0.7);
                            e.shootTimer++;
                            if (e.shootTimer >= 80) {
                                eBullets.push({
                                    x: e.x, y: e.y + 8,
                                    vx: (p.x > e.x ? 1 : -1) * 2, vy: 0.5,
                                    alive: true
                                });
                                e.shootTimer = 0;
                            }
                        }
                        break;

                    case 'boss':
                        e.vy += 0.45;
                        if (e.vy > 8) e.vy = 8;
                        e.moveTimer++;
                        if (e.moveTimer % 100 < 60) {
                            e.vx = (p.x > e.x ? 1.3 : -1.3);
                            e.dir = e.vx > 0 ? 1 : -1;
                        } else {
                            e.vx = 0;
                        }
                        if (e.grounded && e.moveTimer % 80 === 0) e.vy = -9;
                        e.shootTimer++;
                        if (e.shootTimer >= 40) {
                            e.shootTimer = 0;
                            eBullets.push({
                                x: e.x + e.w / 2, y: e.y + e.h / 2,
                                vx: (p.x > e.x ? 1 : -1) * 3, vy: 0,
                                alive: true
                            });
                            if (e.hp < e.maxHp / 2) {
                                eBullets.push({
                                    x: e.x + e.w / 2, y: e.y + e.h / 2,
                                    vx: (p.x > e.x ? 1 : -1) * 2.5, vy: -1.5,
                                    alive: true
                                });
                            }
                        }
                        resolvePhysics(e);
                        break;
                }

                // „Éó„É¨„Ç§„É§„ÉºÂºæ ‚Üí Êïµ
                for (let b of pBullets) {
                    if (!b.alive || !e.alive) continue;
                    if (e.type === 'met' && e.hiding) continue;
                    if (b.x > e.x && b.x < e.x + e.w &&
                        b.y > e.y && b.y < e.y + e.h) {
                        b.alive = false;
                        e.hp--;
                        e.flash = 8;
                        spawnParticles(b.x, b.y, '#fff', 5, { spread: 3, life: 8 });
                        if (e.hp <= 0) {
                            e.alive = false;
                            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2);
                            if (e.type === 'boss') {
                                bossAlive = false;
                                goalReached = true;
                                setTimeout(() => miniGameWin(), 400);
                            }
                        }
                    }
                }

                // ÊïµÊé•Ëß¶„ÉÄ„É°„Éº„Ç∏
                if (e.alive && p.invincible === 0) {
                    if (p.x < e.x + e.w && p.x + p.w > e.x &&
                        p.y < e.y + e.h && p.y + p.h > e.y) {
                        p.hp--;
                        p.invincible = 60;
                        spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#f66', 8, { spread: 5 });
                        if (p.hp <= 0) {
                            p.alive = false;
                            spawnExplosion(p.x + p.w / 2, p.y + p.h / 2);
                            miniGameFail();
                            return;
                        }
                    }
                }
            }

            // ÊïµÂºæ
            for (let b of eBullets) {
                if (!b.alive) continue;
                b.x += b.vx; b.y += b.vy;
                if (b.x < cam.x - 30 || b.x > cam.x + CW + 30 ||
                    b.y < -30 || b.y > mapRows * TILE + 30) {
                    b.alive = false; continue;
                }
                if (isSolid(b.x, b.y)) { b.alive = false; continue; }
                if (p.invincible === 0 &&
                    Math.abs(b.x - (p.x + p.w / 2)) < 12 &&
                    Math.abs(b.y - (p.y + p.h / 2)) < 14) {
                    b.alive = false;
                    p.hp--;
                    p.invincible = 60;
                    spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#f66', 6, { spread: 4 });
                    if (p.hp <= 0) {
                        p.alive = false;
                        spawnExplosion(p.x + p.w / 2, p.y + p.h / 2);
                        miniGameFail();
                        return;
                    }
                }
            }

            // „Ç¢„Ç§„ÉÜ„É†
            for (let item of items) {
                if (!item.alive) continue;
                item.bobPhase += 0.06;
                if (Math.abs(item.x - p.x) < 18 && Math.abs(item.y - p.y) < 18) {
                    item.alive = false;
                    p.hp = Math.min(p.hp + 1, 3);
                    spawnParticles(item.x, item.y, '#4f4', 8, { spread: 4, life: 12 });
                }
            }

            pBullets = pBullets.filter(b => b.alive);
            eBullets = eBullets.filter(b => b.alive);
            updateParticles();
        },

        // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊôÇ„ÅØÂ§±Êïó
        onTimeout() { miniGameFail(); },

        draw() {
            // ËÉåÊôØÔºà„Éë„É©„É©„ÉÉ„ÇØ„ÇπÔºâ
            drawBG_skyWithScroll(cam.x);

            // „Çø„Ç§„É´
            drawTiles(mapData, cam.x, TILE);

            // „Ç¢„Ç§„ÉÜ„É†
            for (let item of items) {
                if (!item.alive) continue;
                drawItem(item.x - cam.x - 8, item.y + Math.sin(item.bobPhase) * 3 - 8,
                    item.type, item.bobPhase);
            }

            // „Éó„É¨„Ç§„É§„Éº
            if (p.alive && (p.invincible === 0 || Math.sin(p.invincible * 0.5) > 0)) {
                drawPlayer(p.x - cam.x, p.y, p.facing, p.walkPhase,
                    p.grounded, p.shootTimer, 0, p.armAngle,
                    p.landSquash, p.jumpStretch, p.eyeBlink);
            }

            // Êïµ
            for (let e of enemies) {
                if (!e.alive) continue;
                const ex = e.x - cam.x;
                if (ex < -50 || ex > CW + 50) continue;
                ctx.globalAlpha = (e.flash > 0 && e.flash % 2 === 0) ? 0.4 : 1;
                switch (e.type) {
                    case 'met':
                        drawMet(ex + e.w / 2, e.y + e.h / 2, e.hiding);
                        break;
                    case 'fly':
                        drawFlyEnemy(ex + e.w / 2, e.y + e.h / 2, frame);
                        break;
                    case 'boss':
                        drawBoss(ex + e.w / 2, e.y + e.h / 2,
                            e.hp, e.maxHp, e.dir, frame, 0.7);
                        break;
                }
                ctx.globalAlpha = 1;
            }

            // „Éó„É¨„Ç§„É§„ÉºÂºæ
            for (let b of pBullets) {
                if (!b.alive) continue;
                drawBullet(b.x - cam.x, b.y, 4, '#44aaff');
            }

            // ÊïµÂºæ
            for (let b of eBullets) {
                if (!b.alive) continue;
                drawBullet(b.x - cam.x, b.y, 4, '#ff4444');
            }

            // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´
            drawParticles(cam.x);

            // „Éó„É¨„Ç§„É§„ÉºHPË°®Á§∫
            const hpBarX = 10, hpBarY = 8, hpBarW = CW * 0.25, hpBarH = 8;
            ctx.fillStyle = '#0008';
            roundRect(hpBarX - 1, hpBarY - 1, hpBarW + 2, hpBarH + 2, 5); ctx.fill();
            ctx.fillStyle = '#333';
            roundRect(hpBarX, hpBarY, hpBarW, hpBarH, 4); ctx.fill();
            const hpR = clamp(p.hp / 3, 0, 1);
            if (hpR > 0) {
                const hpG = ctx.createLinearGradient(hpBarX, hpBarY, hpBarX + hpBarW * hpR, hpBarY);
                hpG.addColorStop(0, hpR > 0.5 ? '#4f4' : '#ff0');
                hpG.addColorStop(1, hpR > 0.5 ? '#2a2' : '#a80');
                ctx.fillStyle = hpG;
                roundRect(hpBarX, hpBarY, hpBarW * hpR, hpBarH, 4); ctx.fill();
            }
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(9, CW * 0.025)}px sans-serif`;
            ctx.textAlign = 'left';
            ctx.fillText(`HP ${p.hp}/3`, hpBarX + hpBarW + 6, hpBarY + hpBarH - 1);

            // „Éê„Éº„ÉÅ„É£„É´„Éë„ÉÉ„Éâ„Ç¨„Ç§„Éâ
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${CW * 0.04}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('‚Üê ÁßªÂãï', CW * 0.17, CH - 15);
            ctx.fillText('ÁßªÂãï / „Ç∏„É£„É≥„Éó‚Üë', CW * 0.5, CH - 15);
            ctx.fillText('„Ç∑„Éß„ÉÉ„Éà ‚Üí', CW * 0.83, CH - 15);
            ctx.globalAlpha = 1;
        }
    };
}
</script>
</body>
</html>
